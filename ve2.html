<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”µBB 3DæŸ¥çœ‹å™¨</title>
    <style>
        :root {
            --app-bg: #f8f9fa;
            --sidebar-bg: #ffffff;
            --accent: #0078d4;
            --accent-light: #106ebe;
            --accent-dark: #005a9e;
            --muted: #605e5c;
            --muted-light: #8a8886;
            --border: #edebe9;
            --border-light: #f3f2f1;
            --btn-hover: #f3f8ff;
            --btn-active: #c7e4f7;
            --card-bg: #faf9f8;
            --radius: 4px;
            --radius-large: 8px;
            --shadow: 0 1.6px 3.6px 0 rgba(0,0,0,0.132), 0 0.3px 0.9px 0 rgba(0,0,0,0.108);
            --shadow-hover: 0 3.2px 7.2px 0 rgba(0,0,0,0.132), 0 0.6px 1.8px 0 rgba(0,0,0,0.108);
            --shadow-strong: 0 6.4px 14.4px 0 rgba(0,0,0,0.132), 0 1.2px 3.6px 0 rgba(0,0,0,0.108);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, "Roboto", "Helvetica Neue", Arial, sans-serif;
            background: var(--app-bg);
            color: #323130;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .container { display: flex; height: 100vh; position: relative; }
        /* ä¾§è¾¹æ ï¼šå¾®è½¯ Fluent é£æ ¼ï¼ˆæ›´ç°ä»£ã€è½»é‡ï¼‰ */
        .sidebar {
            position: absolute;
            right: 12px;
            left: auto;
            top: 12px;
            width: 320px;
            height: calc(100vh - 24px);
            /* å»æ‰çº¯é»‘èƒŒæ™¯ï¼Œæ”¹ä¸ºé€æ˜ä»¥æ˜¾ç¤ºåé¢çš„é¡µé¢èƒŒæ™¯ */
            background: transparent;
            /* ä½¿ç”¨å˜é‡æˆ–è¾ƒæš—æ–‡å­—ä»¥ä¿è¯å¯è¯»æ€§ï¼Œå¡ç‰‡é‡Œä»ä¿æŒæ·±è‰²æ–‡æœ¬ */
            color: var(--sidebar-text, #e6e6e6);
            padding: 12px;
            overflow-y: auto;
            box-shadow: var(--shadow);
            /* ä½¿ç”¨æ›´è½»çš„è¾¹æ¡†ï¼Œè®©ä¾§è¾¹æ åœ¨é€æ˜èƒŒæ™¯ä¸‹ä»å¯è§ */
            border: 1px solid rgba(0,0,0,0.12);
            border-radius: 6px;
            scrollbar-width: thin;
            scrollbar-color: rgba(0,0,0,0.12) transparent;
            z-index: 1100;
            font-size: 13px;
        }
        /* sidebar å†…çš„å¤§å¤šæ•°å¡ç‰‡ä»ä¸ºç™½åº•ï¼Œç¡®ä¿å¡ç‰‡å†…æ–‡æœ¬ä¸ºæ·±è‰² */
        .sidebar .control-group { color: #222; }
        .sidebar h2, .sidebar .app-header h2, .sidebar .panel-title { color: #f3f3f3; }
        .sidebar label, .sidebar .muted, .sidebar .small, .sidebar .hdr-text { color: #d7d7d7; }
        .sidebar .upload-area { border-color: rgba(255,255,255,0.06); background: rgba(255,255,255,0.02); }
        /* åœ¨ control-group å†…ç¡®ä¿æ‰€æœ‰æ–‡æœ¬ä¸ºæ·±è‰²ä»¥ä¿è¯å¯¹æ¯” */
        .sidebar .control-group,
        .sidebar .control-group label,
        .sidebar .control-group .muted,
        .sidebar .control-group .small,
        .sidebar .control-group .hdr-text,
        .sidebar .control-group .group-title,
        .sidebar .control-group .control-btn,
        .sidebar .control-group input,
        .sidebar .control-group select,
        .sidebar .control-group button,
        .sidebar .control-group .file-item {
            color: #222 !important;
        }
        .sidebar .control-group input, .sidebar .control-group select, .sidebar .control-group textarea {
            background: #fff;
            color: #222;
            border: 1px solid var(--border);
        }
        .sidebar .collapsible-header .hdr-text { color: #323130 !important; }
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }
        .sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }
        .viewer-container { flex: 1; position: relative; }
        /* è§†å›¾åŒºä¿æŒçº¯é»‘èƒŒæ™¯ä»¥ä¾¿æŸ¥çœ‹æ¨¡å‹ */
        #viewer { width: 100%; height: 100%; display: block; background: #000000; }

        /* è¾…åŠ©è§†å›¾æ ·å¼ */
        .aux-view-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            min-width: 150px;
            min-height: 120px;
            max-width: 400px;
            max-height: 300px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            overflow: hidden;
            background: #000;
            z-index: 1000;
            display: none; /* é»˜è®¤éšè— */
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            resize: both;
        }

        .aux-view-container:hover {
            border-color: rgba(255,255,255,0.5);
        }

        .aux-view-header {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .aux-view-close {
            cursor: pointer;
            font-size: 14px;
            opacity: 0.7;
        }

        .aux-view-close:hover {
            opacity: 1;
        }

        #auxViewer {
            width: 100%;
            height: calc(100% - 28px);
            display: block;
            background: #000;
        }
        /* å·¦ä¾§èµ„æºé¢æ¿ */
        #leftPanel {
            position: absolute;
            left: 12px;
            top: 68px;
            width: 148px;
            height: calc(100vh - 80px);
            background: var(--sidebar-bg);
            color: #fff;
            padding: 8px;
            border-radius: 6px;
            box-shadow: var(--shadow);
            overflow-y: auto;
            z-index: 1150;
            font-size: 13px;
        }
        #topToolbar {
            position: absolute;
            left: 12px;
            right: 12px;
            top: 12px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 6px 10px;
            background: transparent;
            border-radius: 6px;
            box-shadow: none;
            z-index: 1200;
        }
        /* è°ƒæ•´è§†å›¾åŒºèŒƒå›´ä»¥é¿å¼€å·¦å³é¢æ¿ä¸é¡¶éƒ¨å·¥å…·æ  */
        .viewer-container {
            position: absolute;
            left: 172px;
            right: 344px;
            top: 68px;
            bottom: 0;
        }
        
        .upload-area {
            border: 2px dashed var(--border);
            border-radius: var(--radius-large);
            padding: 24px 16px;
            text-align: center;
            margin-bottom: 16px;
            background: var(--card-bg);
            transition: all 0.2s ease;
        }
        .upload-area:hover {
            border-color: var(--accent);
            background: var(--btn-hover);
        }
        .upload-btn {
            padding: 8px 16px;
            border-radius: var(--radius);
            background: var(--accent);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            box-shadow: var(--shadow);
            transition: all 0.2s ease;
            margin-top: 8px;
        }
        .upload-btn:hover {
            background: var(--accent-light);
            box-shadow: var(--shadow-hover);
            transform: translateY(-1px);
        }
        .upload-btn:active {
            background: var(--accent-dark);
            transform: translateY(0);
        }
        .control-panel {
            margin-top: 16px;
            background: transparent;
        }
        .control-group {
            margin-bottom: 20px;
            background: var(--card-bg);
            border-radius: var(--radius-large);
            padding: 16px;
            border: 1px solid var(--border-light);
            transition: all 0.2s ease;
        }
        .control-group:hover {
            box-shadow: var(--shadow-hover);
            border-color: var(--accent);
        }
        /* å³ä¾§é¢æ¿åŒºåˆ†è‰²ï¼šåœ¨æ¯ä¸ª control-group å·¦ä¾§æ˜¾ç¤ºå½©è‰²æ¡ä»¥ä¾¿å¿«é€Ÿè¯†åˆ« */
        /* å–æ¶ˆå³ä¾§ control-group çš„åŒºåˆ†è‰²æ¡ï¼Œæ¢å¤é»˜è®¤å†…è¾¹è· */
        .sidebar .control-group {
            position: relative;
            padding-left: 0;
        }
        .sidebar .control-group::before {
            display: none;
        }
        /* è°ƒè‰²æ¿ï¼ˆæŒ‰é¡ºåºæ˜ å°„åˆ°é¢æ¿é¡¹ï¼‰ */
        .sidebar .control-group:nth-of-type(1)::before { background: #106ebe; }   /* è“ */
        .sidebar .control-group:nth-of-type(2)::before { background: #0b6a3d; }   /* ç»¿ */
        .sidebar .control-group:nth-of-type(3)::before { background: #d97706; }   /* æ©™ */
        .sidebar .control-group:nth-of-type(4)::before { background: #8b5cf6; }   /* ç´« */
        .sidebar .control-group:nth-of-type(5)::before { background: #e11d48; }   /* çº¢ */
        .sidebar .control-group:nth-of-type(6)::before { background: #0891b2; }   /* é’ */
        .sidebar .control-group:nth-of-type(7)::before { background: #f59e0b; }   /* é»„æ©™ */
        .sidebar .control-group:nth-of-type(8)::before { background: #6b7280; }   /* ç° */
        /* å¦‚æœé¢æ¿é¡¹æ›´å¤šï¼Œé‡å¤æˆ–ä¿æŒé»˜è®¤è‰² */
        .control-group .group-title {
            font-weight: 600;
            font-size: 14px;
            color: #323130;
            margin-bottom: 12px;
            display: block;
            letter-spacing: 0.025em;
        }
        .control-btn {
            width: 100%;
            padding: 8px 12px;
            margin-top: 6px;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            background: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: #323130;
            transition: all 0.15s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .icon-btn {
            display: inline-flex;
            width: 28px;
            height: 28px;
            padding: 4px;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: white;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }
        .icon-btn svg { width: 14px; height: 14px; }
        .icon-btn:hover { background: var(--btn-hover); border-color: var(--accent); box-shadow: var(--shadow); }
        /* æ˜æ˜¾çš„ä¿å­˜æˆªå›¾æŒ‰é’®æ ·å¼ */
        .icon-btn.save-screenshot-btn {
            background: var(--accent);
            color: #ffffff;
            border-color: var(--accent);
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        .icon-btn.save-screenshot-btn svg { stroke: #ffffff; fill: #ffffff; }
        /* Top toolbar icons larger */
        #topToolbar .icon-btn { width:36px; height:36px; padding:6px; }
        #topToolbar { padding:6px 12px; }
        .control-btn:hover {
            background: var(--btn-hover);
            border-color: var(--accent);
            box-shadow: var(--shadow);
            transform: translateY(-1px);
        }
        .control-btn:active {
            background: var(--btn-active);
            transform: translateY(0);
        }
        #lightsList div {
            margin-top: 8px;
            font-size: 13px;
            background: var(--card-bg);
            padding: 12px;
            border-radius: var(--radius);
            border: 1px solid var(--border-light);
            transition: all 0.2s ease;
        }
        #lightsList div:hover {
            border-color: var(--accent);
            box-shadow: var(--shadow);
        }
        input[type="range"] {
            width: 100%;
            margin-top: 8px;
            accent-color: var(--accent);
            height: 6px;
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: var(--shadow);
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
            box-shadow: var(--shadow);
        }
        input[type="number"], input[type="text"], select {
            padding: 6px 8px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            font-size: 13px;
            font-family: inherit;
            transition: all 0.2s ease;
            background: white;
        }
        input[type="number"]:focus, input[type="text"]:focus, select:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(0,120,212,0.2);
            outline: none;
        }
        .sidebar h2 {
            font-size: 20px;
            margin-bottom: 16px;
            color: #323130;
            font-weight: 600;
            letter-spacing: -0.025em;
        }
        .muted {
            color: var(--muted);
            font-size: 12px;
            font-weight: 400;
        }
        .section-sep {
            height: 1px;
            background: var(--border);
            margin: 16px 0;
            border-radius: 1px;
        }
        /* ä½¿ checkbox / labels çœ‹èµ·æ¥æ›´æ•´æ´ */
        label {
            font-size: 13px;
            color: #323130;
            font-weight: 500;
            cursor: pointer;
        }
        .small {
            font-size: 12px;
            color: var(--muted);
            font-weight: 400;
        }

        /* å¯æŠ˜å é¢æ¿æ ·å¼ */
        .collapsible-header {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 6px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #323130;
            user-select: none;
        }
        .collapsible-header .chevron {
            transition: transform 0.18s ease;
            color: var(--accent);
            font-size: 12px;
            line-height: 1;
        }
        .control-group .content {
            margin-top: 8px;
            transition: max-height 0.22s ease, opacity 0.18s ease, padding 0.18s ease;
            overflow: hidden;
            max-height: 2000px;
            opacity: 1;
        }
        .control-group.collapsed .content {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        .control-group.collapsed .collapsible-header .chevron {
            transform: rotate(-90deg);
        }
        /* header / logo */
        .app-header { display:flex; align-items:center; gap:10px; margin-bottom:14px; }
        .app-header .logo {
            width:34px;
            height:34px;
            border-radius:8px;
            background: linear-gradient(180deg,var(--accent),var(--accent-light));
            display:flex;
            align-items:center;
            justify-content:center;
            color:white;
            font-weight:700;
            box-shadow: var(--shadow);
            font-size:13px;
        }
        .app-header h2 {
            font-size:16px;
            color: #111;
            margin: 0;
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        /* ä¼˜åŒ–æ§ä»¶å¡ç‰‡è§†è§‰å±‚çº§ */
        .control-group {
            background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(250,250,250,0.98));
            border: 1px solid rgba(0,0,0,0.04);
        }
        /* æ›´å¹²å‡€çš„æŒ‰é’®å¤–è§‚ */
        .control-btn {
            background: linear-gradient(180deg, #ffffff, #fbfbfb);
            border: 1px solid var(--border-light);
            color: #222;
        }
        .control-btn:hover {
            background: linear-gradient(180deg, var(--btn-hover), #fff);
            box-shadow: var(--shadow-hover);
        }
        /* æ›´ç´§å‡‘çš„æ–‡ä»¶åˆ—è¡¨é¡¹ */
        .file-item { padding:10px; }
        .file-item:hover { box-shadow: var(--shadow); border-color: var(--border-light); }
        /* åº•éƒ¨ç›¸æœºä¿¡æ¯æ¡ */
        .bottom-info {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 18px;
            min-width: 360px;
            max-width: 80%;
            background: rgba(10,10,10,0.75);
            color: #e6e6e6;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.06);
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
            z-index: 1200;
            font-size: 13px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.6);
        }
        .bottom-info .bi-item { display:flex; gap:8px; align-items:center; }
        .bottom-info .bi-label { color: #b9c3d0; font-weight:600; margin-right:6px; }
        .bottom-info .bi-value { color: #ffffff; font-weight:700; }

        /* é¢å¤–çš„åŠ¨ç”»å’Œäº¤äº’æ•ˆæœ */
        .control-btn:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        /* ä¸ºæ•°å€¼æ˜¾ç¤ºæ·»åŠ æ›´å¥½çš„æ ·å¼ */
        #camFovVal, #ambientVal, #dirVal, #modelSizeVal {
            font-weight: 600;
            color: var(--accent);
            background: var(--btn-hover);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }

        /* æ”¹è¿›checkboxæ ·å¼ */
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* ä¸ºè§†å›¾æ–¹å‘å’Œæ™¯åˆ«æ˜¾ç¤ºæ·»åŠ å¡ç‰‡æ ·å¼ */
        #viewDirection, #shotScale {
            background: var(--card-bg);
            padding: 8px 12px;
            border-radius: var(--radius);
            border: 1px solid var(--border-light);
            margin-top: 4px;
            transition: all 0.2s ease;
        }

        #viewDirection:hover, #shotScale:hover {
            border-color: var(--accent);
            box-shadow: var(--shadow);
        }
    </style>
</head>
<body>
    <div id="topToolbar" role="toolbar" aria-label="å·¥å…·æ ">
        <button class="icon-btn" title="é‡ç½®ç›¸æœº" onclick="resetCamera()" aria-label="é‡ç½®ç›¸æœº">
            <svg viewBox="0 0 24 24" fill="none" stroke="#323130" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v4"/><path d="M5 7l2-2"/><path d="M19 7l-2-2"/><circle cx="12" cy="14" r="6"/></svg>
        </button>
        <button class="icon-btn" title="é€‚åº”è§†å›¾" onclick="fitToView()" aria-label="é€‚åº”è§†å›¾">
            <svg viewBox="0 0 24 24" fill="none" stroke="#323130" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h6v6H4z"/><path d="M20 20h-6v-6h6z"/><path d="M20 4h-6v6h6z"/><path d="M4 20h6v-6H4z"/></svg>
        </button>
        <!-- æˆªå±å›¾æ ‡æŒ‰é’®ï¼ˆå·²ç§»é™¤ï¼‰ -->
        <!-- æ˜æ˜¾çš„ä¿å­˜æˆªå›¾å¹¶è¦†ç›– image.png æŒ‰é’® -->
        <button class="icon-btn save-screenshot-btn" title="ä¿å­˜æˆªå›¾åˆ°æ’ä»¶ç›®å½• (è¦†ç›– image.png)" onclick="saveScreenshotToServer()" aria-label="ä¿å­˜æˆªå›¾åˆ°æ’ä»¶ç›®å½•">
            <svg viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2v6" />
                <rect x="3" y="8" width="18" height="12" rx="2" />
                <circle cx="12" cy="14" r="2.2" />
            </svg>
        </button>
        
        <button class="icon-btn" title="ä¿å­˜å·¥ç¨‹" onclick="saveProject()" aria-label="ä¿å­˜å·¥ç¨‹">
            <svg viewBox="0 0 24 24" fill="none" stroke="#323130" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/></svg>
        </button>
        <button class="icon-btn" title="åŒæ­¥å…‰ç…§" onclick="regenerateEnvLighting()" aria-label="åŒæ­¥å…‰ç…§">
            <svg viewBox="0 0 24 24" fill="none" stroke="#323130" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M23 20v-6h-6"/><path d="M20.49 9A9 9 0 1 0 22 12"/></svg>
        </button>
    </div>
    <div id="leftPanel" aria-label="èµ„æºé¢æ¿">
        <div style="font-weight:600; margin-bottom:8px; color:#323130;">èµ„æº</div>
        <div id="fileListLeft" style="font-size:13px; color:#222;"></div>
    </div>
    <div class="container">
        <div class="sidebar">
            <div class="app-header" role="banner">
                <div class="logo" aria-hidden>BB</div>
                <h2 style="margin:0;">ğŸ”µBB 3DæŸ¥çœ‹å™¨</h2>
            </div>

            <div class="upload-area" id="uploadArea">
                <p>æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ </p>
                <input type="file" id="fileInput" class="file-input" multiple accept=".obj,.fbx,.glb,.gltf,.dae,.3ds,.ply,.stl,image/*,.png,.jpg,.jpeg,.webp,.bmp" style="display:none;">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">é€‰æ‹©æ–‡ä»¶</button>
                <p style="font-size:12px; margin-top:12px; color:var(--muted);">æ”¯æŒæ ¼å¼: OBJ, FBX, GLB/GLTF, DAE, PLY, STL</p>
            </div>

            <div class="control-panel">
                <div class="control-group">
                    <div style="font-weight:bold;">å·¥ç¨‹æ–‡ä»¶</div>
                    <button class="control-btn" onclick="saveProject()" id="saveBtn">ğŸ’¾ ä¿å­˜å·¥ç¨‹</button>
                    <button class="control-btn" onclick="saveProjectAs()">ğŸ’¾ å¦å­˜ä¸º</button>
                    <button class="control-btn" onclick="document.getElementById('loadProjectInput').click()">ğŸ“ æ‰“å¼€å·¥ç¨‹</button>
                    <button class="control-btn" onclick="authorizeOverwrite()" title="åœ¨æ”¯æŒçš„æµè§ˆå™¨ä¸­æˆæƒä»¥å…è®¸è¦†ç›–ä¿å­˜">ğŸ” å…è®¸è¦†ç›–ä¿å­˜</button>
                    <input type="file" id="loadProjectInput" accept=".bbproject" style="display:none;" onchange="loadProjectFromFile(this.files[0])">
                    <div id="projectStatus" style="font-size:12px; margin-top:8px; color:var(--muted);">
                        æœªä¿å­˜
                    </div>
                    <p style="font-size:12px; margin-top:4px; color:var(--muted);">æ”¯æŒæ ¼å¼: .bbproject</p>
                </div>

                <div class="control-group">
                    <div style="font-weight:bold;">è§†å›¾æ§åˆ¶</div>
                    <button class="control-btn" onclick="resetCamera()">é‡ç½®ç›¸æœº</button>
                    <button class="control-btn" onclick="fitToView()">é€‚åº”è§†å›¾</button>
                    <div style="margin-top:8px;">
                        <button class="control-btn" onclick="captureCurrentView()">ğŸ“· å›ºå®šå½“å‰è§†è§’</button>
                        <button class="control-btn" onclick="hideAuxView()">âŒ éšè—è¾…åŠ©è§†å›¾</button>
                    </div>
                </div>

                <div class="control-group">
                    <div style="font-weight:bold;">æ¨¡å‹æ§åˆ¶</div>
            <button class="control-btn" onclick="showWireframe()">çº¿æ¡†æ¨¡å¼</button>
            <button class="control-btn" onclick="showSolid()">å®ä½“æ¨¡å¼</button>
            <div style="display:flex; gap:8px; margin-top:8px;">
                <button class="control-btn" style="flex:1;" onclick="toggleTransform()">å¯ç”¨å˜æ¢</button>
                <button class="control-btn" style="flex:1;" onclick="setTransformMode('translate')">ç§»åŠ¨</button>
                <button class="control-btn" style="flex:1;" onclick="setTransformMode('rotate')">æ—‹è½¬</button>
                <button class="control-btn" style="flex:1;" onclick="setTransformMode('scale')">ç¼©æ”¾</button>
            </div>
            <div style="margin-top:8px; display:flex; align-items:center; gap:8px;">
                <input type="checkbox" id="uniformScale" onchange="toggleUniformScale(this.checked)" />
                <label for="uniformScale" style="margin:0;">ç­‰æ¯”ä¾‹ç¼©æ”¾</label>
            </div>
                <div style="margin-top:8px; display:flex; align-items:center; gap:8px;">
                    <input type="checkbox" id="uniformAlign" checked onchange="toggleUniformAlign(this.checked)" />
                    <label for="uniformAlign" style="margin:0;">ç»Ÿä¸€å¤§å°ä¸ä½ç½®</label>
                </div>
                <div style="margin-top:8px;">
                    <label>æ¨¡å‹ç»Ÿä¸€å°ºå¯¸: <span id="modelSizeVal">1.0</span></label>
                    <input type="range" min="0.1" max="5" step="0.1" value="1.0" oninput="updateModelTargetSize(this.value)" />
                    <div style="display:flex; gap:4px; margin-top:4px;">
                        <button class="control-btn" style="flex:1; padding:4px;" onclick="setModelTargetSize(1.0)">å°(1.0)</button>
                        <button class="control-btn" style="flex:1; padding:4px;" onclick="setModelTargetSize(2.0)">ä¸­(2.0)</button>
                        <button class="control-btn" style="flex:1; padding:4px;" onclick="setModelTargetSize(3.0)">å¤§(3.0)</button>
                    </div>
                </div>
                </div>

                <div class="control-group">
                    <div style="font-weight:bold;">èƒŒæ™¯</div>
                    <button class="control-btn" onclick="setBackground('white')">ç™½è‰²èƒŒæ™¯</button>
                    <button class="control-btn" onclick="setBackground('black')">é»‘è‰²èƒŒæ™¯</button>
                    <button class="control-btn" onclick="setBackground('gradient')">é»‘â†’ä¸­ç° æ¸å˜</button>
                    <div style="margin-top:8px;">
                        <label style="display:block; margin-bottom:4px;">è‡ªå®šä¹‰é¢œè‰²:</label>
                        <input type="color" id="bgColorPicker" value="#ffffff" onchange="setCustomBackground(this.value)" style="width:100%; height:32px; border:1px solid var(--border); border-radius:4px; cursor:pointer;" />
                        <div style="margin-top:4px; font-size:12px; color:var(--muted); text-align:center;" id="bgColorValue">#ffffff</div>
                    </div>
                </div>
                <div class="control-group">
                    <div style="font-weight:bold;">åœºæ™¯</div>
                    <label style="display:flex; align-items:center; gap:8px;">
                        <input type="checkbox" id="toggleGrid" checked onchange="toggleGrid(this.checked)" />
                        <span>æ˜¾ç¤ºåœ°é¢ç½‘æ ¼</span>
                    </label>
                </div>
                <!-- å›¾ç‰‡æ§ä»¶å·²ç§»é™¤ï¼ˆæŒ‰ç”¨æˆ·è¦æ±‚ï¼‰ -->
                <div class="control-group">
                    <div style="font-weight:bold;">ç›¸æœºä¿¡æ¯</div>
                    <label>è§†è§’ (FOV Â°): <span id="camFovVal">75</span>Â°</label>
                    <input id="camFovSlider" type="range" min="10" max="120" step="0.5" value="75" oninput="setCameraFovFromUI(this.value)" />
                    <label>ç„¦è· (35mm ç­‰æ•ˆ, mm): <input id="camFocalInput" type="number" step="0.1" value="35" style="width:100px;" oninput="setCameraFocalFromUI(this.value)" /> </label>
                    <div style="margin-top:8px; font-size:13px;">
                        <div id="camSummary">â€”</div>
                    </div>
                </div>
                <div class="control-group">
                    <div style="font-weight:bold;">è§†å›¾æ–¹å‘</div>
                    <div id="viewDirection" style="font-weight:600; font-size:14px;">â€”</div>
                </div>
                <div class="control-group">
                    <div style="font-weight:bold;">æ™¯åˆ«</div>
                    <div id="shotScale" style="font-weight:600; font-size:14px;">â€”</div>
                </div>
                <div class="control-group">
                    <div style="font-weight:bold;">æˆªå±æ¡†</div>
                    <label style="display:flex; align-items:center; gap:8px;">
                        <input type="checkbox" id="toggleCaptureFrame" onchange="toggleCaptureFrame(this.checked)" />
                        <span>æ˜¾ç¤ºæˆªå±æ¡†</span>
                    </label>
                    <div style="margin-top:8px;">
                        å®½åº¦ (%): <input id="captureWidthRange" type="range" min="10" max="100" step="1" value="60" oninput="setCaptureFrameWidth(this.value)" />
                        <input id="captureWidthInput" type="number" min="10" max="100" step="1" value="60" style="width:64px;" oninput="setCaptureFrameWidth(this.value)" />
                    </div>
                    <div style="margin-top:6px;">
                        é«˜åº¦ (%): <input id="captureHeightRange" type="range" min="10" max="100" step="1" value="60" oninput="setCaptureFrameHeight(this.value)" />
                        <input id="captureHeightInput" type="number" min="10" max="100" step="1" value="60" style="width:64px;" oninput="setCaptureFrameHeight(this.value)" />
                    </div>
                    <!-- å¯¼å‡ºæˆªå± æ§ä»¶ï¼ˆå·²ç§»é™¤ï¼‰ -->
                </div>
                <div class="control-group">
                    <div style="font-weight:bold;">æˆªå±æ¡†æ¨¡å¼</div>
                    <label style="display:flex; align-items:center; gap:8px;">
                        <input type="checkbox" id="captureUsePixels" onchange="toggleCaptureUsePixels(this.checked)" />
                        <span>ä½¿ç”¨åƒç´ è®¾ç½®å®½é«˜</span>
                    </label>
                    <div style="margin-top:8px;">
                        å®½åº¦ (px): <input id="captureWidthPx" type="number" min="1" step="1" value="800" style="width:120px;" oninput="setCaptureFrameWidthPx(this.value)" />
                    </div>
                    <div style="margin-top:6px;">
                        é«˜åº¦ (px): <input id="captureHeightPx" type="number" min="1" step="1" value="600" style="width:120px;" oninput="setCaptureFrameHeightPx(this.value)" />
                    </div>
                    <div style="margin-top:8px;">
                        <label style="display:flex; align-items:center; gap:8px;">
                            <input type="checkbox" id="captureIncludeBg" checked onchange="toggleCaptureIncludeBg(this.checked)" />
                            <span>å¯¼å‡ºæ—¶åŒ…å«èƒŒæ™¯</span>
                        </label>
                    </div>
                </div>
                <div class="control-group">
                    <div style="font-weight:bold;">ç¯å…‰è®¾ç½®</div>
                    <label>ç¯å¢ƒå…‰å¼ºåº¦: <span id="ambientVal">0.6</span></label>
                    <input type="range" min="0" max="2" step="0.05" value="0.6" oninput="updateAmbientIntensity(this.value)" />
                    <label>æ–¹å‘å…‰å¼ºåº¦: <span id="dirVal">0.8</span></label>
                    <input type="range" min="0" max="4" step="0.05" value="0.8" oninput="updateDirectionalIntensity(this.value)" />
                    <label>æ–¹å‘å…‰ä½ç½® (X,Y,Z)</label>
                    <div style="display:flex; gap:6px; margin-bottom:6px;">
                        <input type="number" step="0.1" value="10" style="width:70px;" oninput="updateDirectionalPos(this.value,null,null)" id="dirX" />
                        <input type="number" step="0.1" value="10" style="width:70px;" oninput="updateDirectionalPos(null,this.value,null)" id="dirY" />
                        <input type="number" step="0.1" value="5" style="width:70px;" oninput="updateDirectionalPos(null,null,this.value)" id="dirZ" />
                    </div>

                    <button class="control-btn" onclick="resetLighting()">é‡ç½®ç¯å…‰</button>

                    <div style="margin-top:12px; border-top:1px dashed var(--border-light); padding-top:10px;">
                        <div style="font-weight:600; margin-bottom:6px;">ç¯å¢ƒç…§æ˜</div>
                        <input type="file" id="hdriInput" accept=".hdr,.exr,image/*" style="display:none;" />
                        <button class="control-btn" onclick="document.getElementById('hdriInput').click()" style="width:100%; margin-bottom:6px;">åŠ è½½ HDRI / å›¾ç‰‡</button>
                        <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px;">
                            <input type="color" id="envColorPicker" value="#ffffff" style="flex:1;" />
                            <input type="range" id="envColorIntensity" min="0" max="4" step="0.05" value="1.0" style="width:120px;" />
                        </div>
                        <div style="display:flex; gap:8px; margin-bottom:6px;">
                            <button class="control-btn" onclick="applyEnvColor()" style="flex:1;">åº”ç”¨é¢œè‰²ç¯å¢ƒ</button>
                            <button class="control-btn" onclick="clearEnvMap()" style="flex:1;">æ¸…é™¤ç¯å¢ƒè´´å›¾</button>
                        </div>
                        <div style="margin-top:8px; border-top:1px dashed var(--border-light); padding-top:8px;">
                            <label style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                                <input type="checkbox" id="hdriVisible" checked onchange="(function(checked){ if(viewer) { if(!checked) viewer.scene.background = null; else if(viewer._currentEnvMap) viewer.scene.background = viewer._currentEnvMap; } })(this.checked)" />
                                <span>æ˜¾ç¤º HDRI èƒŒæ™¯</span>
                            </label>
                            <div id="hdriStatus" style="font-size:12px; margin-top:6px; color:var(--muted);">æœªåŠ è½½ HDRI</div>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <div style="font-weight:bold;">ç¯å…‰ç®¡ç†</div>
                    <button class="control-btn" onclick="addDirectionalLight()">æ·»åŠ æ–¹å‘å…‰ï¼ˆè§†å›¾ä¸­å¿ƒï¼‰</button>
                    <div style="margin-top:8px;">
                        <label style="display:flex; align-items:center; gap:8px;">
                            <input type="checkbox" id="toggleHelpers" checked onchange="toggleLightHelpers(this.checked)" />
                            <span>æ˜¾ç¤ºç¯å…‰åŠ©æ‰‹</span>
                        </label>
                    </div>
                    <div id="lightsList"></div>
                </div>
            </div>

            
        </div>

        <div class="viewer-container">
            <div id="viewer"></div>

            <!-- è¾…åŠ©è§†å›¾çª—å£ -->
            <div class="aux-view-container" id="auxViewContainer">
                <div class="aux-view-header">
                    <span>å›ºå®šè§†è§’</span>
                    <span class="aux-view-close" onclick="hideAuxView()">Ã—</span>
                </div>
                <div id="auxViewer"></div>
            </div>

            <!-- åº•éƒ¨ç›¸æœº/è§†å›¾ä¿¡æ¯æ¡ -->
            <div class="bottom-info" id="bottomInfo" aria-live="polite">
                <div class="bi-item"><span class="bi-label">Camera:</span><span class="bi-value" id="bottomCamSummary">â€”</span></div>
                <div class="bi-item"><span class="bi-label">View:</span><span class="bi-value" id="bottomViewDirection">â€”</span></div>
                <div class="bi-item"><span class="bi-label">Shot:</span><span class="bi-value" id="bottomShotScale">â€”</span></div>
            </div>
        </div>
    </div>

    <!-- Three.js å’Œ åŠ è½½å™¨ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/ColladaLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/PLYLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <script>
// 3Dæ–‡ä»¶æŸ¥çœ‹å™¨ä¸»è„šæœ¬
class ModelViewer {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.currentModel = null;
        this.models = [];
        this.history = [];
        this.historyIndex = -1;
        this.loaders = {};
        this.lights = [];
        this.axesHelper = null;
        // é€‰æ‹©æ¡†è¾…åŠ©ï¼ˆä½¿ç”¨ BoxHelper æ˜¾ç¤ºé»„è‰²çº¿æ¡†ï¼‰
        this.selectionBox = null;
        this.raycaster = null;
        this.pointer = null;
        this.isDraggingLight = false;
        this.dragPlane = null;
        this.dragOffset = null;
        this.lightHelper = null;
        this.userLights = {}; // å­˜å‚¨ç”¨æˆ·åˆ›å»ºçš„ç¯å…‰ {id: {light, helper, type}}
        this.lightIdCounter = 0;
        this.draggingLightId = null;
        this.helpersVisible = true;
        this.gridHelper = null;
        // ç›®æ ‡æ¨¡å‹å¤§å°ï¼ˆæ¨¡å‹çš„æœ€å¤§è¾¹é•¿åº¦ä¼šè¢«ç¼©æ”¾åˆ°æ­¤å€¼ï¼‰
        this.modelTargetSize = 1.0;
        this.uniformAlign = true;
        // æ’¤é”€æ ˆ
        this.undoStack = [];
        this.maxUndo = 100;
        this._suppressUndo = false;

        // å·¥ç¨‹æ–‡ä»¶çŠ¶æ€
        this.currentProjectFileName = null;
        this.hasUnsavedChanges = false;

        // è¾…åŠ©è§†å›¾ç›¸å…³
        this.auxCamera = null;
        this.auxRenderer = null;
        this.auxViewVisible = false;
        this.auxViewLocked = false; // æ˜¯å¦å·²é”å®šè§†è§’

        // å›¾ç‰‡ç›¸å…³ï¼ˆå·²ç§»é™¤ï¼‰

        this.init();
        this.setupLoaders();
        this.setupLights();
        this.setupHelpers();
        this.setupEventListeners();
        this.setupAuxView();
        this.animate();
    }

    init() {
        console.log('åˆå§‹åŒ–3Dåœºæ™¯...');

        // åˆ›å»ºåœºæ™¯ï¼ˆé»˜è®¤ä¸è®¾ç½® scene.backgroundï¼Œä½¿ç”¨å®¹å™¨çš„ CSS æ¸å˜ä½œä¸ºèƒŒæ™¯ï¼‰
        this.scene = new THREE.Scene();
        this.scene.background = null;
        console.log('åœºæ™¯åˆ›å»ºæˆåŠŸ');

        // åˆ›å»ºç›¸æœº
        const container = document.getElementById('viewer');
        if (!container) {
            throw new Error('æ‰¾ä¸åˆ°viewerå®¹å™¨');
        }
        const width = container.clientWidth;
        const height = container.clientHeight;
        console.log('å®¹å™¨å°ºå¯¸:', width, height);

        this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        this.camera.position.set(5, 5, 5);
        console.log('ç›¸æœºåˆ›å»ºæˆåŠŸ');

        // åˆ›å»ºæ¸²æŸ“å™¨ï¼ˆå¯ç”¨ alpha ä»¥æ˜¾ç¤ºå®¹å™¨çš„ CSS æ¸å˜èƒŒæ™¯ï¼‰
        // preserveDrawingBuffer:true ç¡®ä¿å¯ä»¥ä» canvas è¯»å–åƒç´ ç”¨äºæˆªå›¾/å¯¼å‡º
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true, premultipliedAlpha: false });
        this.renderer.setSize(width, height);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        // å¼€å¯ tone mappingï¼Œä»¥ä¾¿é€šè¿‡æ›å…‰æ§åˆ¶å…¨å±€äº®åº¦
        try {
            this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            this.renderer.toneMappingExposure = 1;
        } catch (e) {
            // three ç‰ˆæœ¬å¯èƒ½ä¸æ”¯æŒï¼Œå¿½ç•¥
        }

        container.appendChild(this.renderer.domElement);
        // ç¡®ä¿å®¹å™¨å¯ä»¥å®šä½ä»¥ä¾¿è¦†ç›–å±‚å®šä½
        try {
            container.style.position = container.style.position || 'relative';
        } catch (e) {}

        // åˆ›å»ºæˆªå±æ¡† overlayï¼ˆé»˜è®¤éšè—ï¼‰
        try {
            const overlay = document.createElement('div');
            overlay.id = 'captureFrame';
            overlay.style.position = 'absolute';
            overlay.style.border = '3px solid rgba(255,80,80,0.95)';
            overlay.style.pointerEvents = 'none';
            overlay.style.left = '50%';
            overlay.style.top = '50%';
            overlay.style.transform = 'translate(-50%,-50%)';
            overlay.style.width = '60%';
            overlay.style.height = '60%';
            overlay.style.zIndex = '999';
            overlay.style.display = 'none';
            container.appendChild(overlay);
            this.captureFrameEl = overlay;
            this.captureFrameSize = { mode: 'pct', wPct: 60, hPct: 60, wPx: 800, hPx: 600 };
            this.captureFrameVisible = false;
            this.captureIncludeBackground = true;
        } catch (e) {
            console.warn('åˆ›å»ºæˆªå±æ¡†å¤±è´¥', e);
            this.captureFrameEl = null;
            this.captureFrameSize = { mode: 'pct', wPct: 60, hPct: 60, wPx: 800, hPx: 600 };
            this.captureFrameVisible = false;
        }
        // å¦‚æœ URL å¸¦æœ‰ #capture:tokenï¼Œåˆ™åœ¨åŠ è½½æ—¶è§¦å‘ä¸€æ¬¡æˆªå›¾å¹¶ä¸Šä¼ 
        try {
            const handleHashCapture = () => {
                try {
                    const h = location.hash || '';
                    if (h && h.startsWith('#capture:')) {
                        // è°ƒç”¨å¯¼å‡ºå‡½æ•°å¹¶ä¸Šä¼ ï¼ˆexportCaptureImage å†…ä¹Ÿä¼šå°è¯•ä¸Šä¼ ï¼‰
                        if (typeof this.exportCaptureImage === 'function') {
                            this.exportCaptureImage();
                        }
                    }
                } catch (e) {}
            };
            window.addEventListener('hashchange', handleHashCapture);
            // é¡µé¢åˆæ¬¡åŠ è½½å¦‚æœå·²ç»å¸¦ hashï¼Œä¹Ÿå°è¯•ä¸€æ¬¡
            setTimeout(handleHashCapture, 100);
        } catch (e) {}
        console.log('æ¸²æŸ“å™¨åˆ›å»ºæˆåŠŸ');

        // å‰ç«¯çŸ­è½®è¯¢ï¼šæ¯ç§’å‘æœåŠ¡å™¨è¯·æ±‚æ˜¯å¦æœ‰æ–°çš„ capture token
        try {
            const pollIntervalMs = 1000;
            async function pollForCaptureCommands() {
                try {
                    const resp = await fetch('/next_command');
                    if (!resp.ok) return;
                    const j = await resp.json();
                    if (j && j.token) {
                        // å°† token æš‚å­˜ä¸º hash å¹¶è§¦å‘æˆªå›¾å¯¼å‡ºï¼ˆexportCaptureImage ä¼šæ£€æµ‹ hash å¹¶ä¸Šä¼ ï¼‰
                        try {
                            location.hash = '#capture:' + j.token;
                        } catch (e) {}
                        if (typeof viewer !== 'undefined' && viewer && typeof viewer.exportCaptureImage === 'function') {
                            try { viewer.exportCaptureImage(); } catch (e) {}
                        } else if (typeof window.viewer !== 'undefined' && window.viewer && typeof window.viewer.exportCaptureImage === 'function') {
                            try { window.viewer.exportCaptureImage(); } catch (e) {}
                        }
                    }
                } catch (e) {
                    // ignore
                }
            }
            setInterval(pollForCaptureCommands, pollIntervalMs);
        } catch (e) {}

        // åˆ›å»ºè½¨é“æ§åˆ¶å™¨
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        // ç¦ç”¨é˜»å°¼ï¼ˆæƒ¯æ€§ï¼‰ï¼Œä¿è¯æ—‹è½¬/å¹³ç§»/ç¼©æ”¾ç«‹å³åœæ­¢
        this.controls.enableDamping = false;
        this.controls.dampingFactor = 0;
        this.controls.enableZoom = true;
        this.controls.enableRotate = true;
        this.controls.enablePan = true;
        console.log('æ§åˆ¶å™¨åˆ›å»ºæˆåŠŸ');
        // TransformControlsï¼ˆç”¨äºç§»åŠ¨/æ—‹è½¬/ç¼©æ”¾æ¨¡å‹ï¼‰
        try {
            this.transformControls = new THREE.TransformControls(this.camera, this.renderer.domElement);
            this.transformControls.addEventListener('dragging-changed', (event) => {
                // å½“æ‹–æ‹½æ—¶ç¦ç”¨ OrbitControlsï¼Œé‡Šæ”¾æ—¶æ¢å¤
                if (this.controls) this.controls.enabled = !event.value;
                this.isTransformDragging = !!event.value;

                // è®°å½• transform çš„å¼€å§‹ä¸ç»“æŸçŠ¶æ€ä»¥æ”¯æŒæ’¤é”€ï¼ˆundoï¼‰
                try {
                    if (event.value) {
                        // å¼€å§‹æ‹–æ‹½ï¼šè®°å½•åˆå§‹å˜æ¢
                        if (this.transformControls && this.transformControls.object) {
                            const obj = this.transformControls.object;
                            this._transformBefore = {
                                id: obj.userData && obj.userData._modelId,
                                position: obj.position.clone(),
                                rotation: obj.rotation.clone(),
                                scale: obj.scale.clone()
                            };
                        } else {
                            this._transformBefore = null;
                        }
                    } else {
                        // ç»“æŸæ‹–æ‹½ï¼šè®°å½•ç»“æŸå˜æ¢å¹¶æ¨å…¥ undo æ ˆ
                        if (this.transformControls && this.transformControls.object && this._transformBefore) {
                            const obj = this.transformControls.object;
                            const after = {
                                position: obj.position.clone(),
                                rotation: obj.rotation.clone(),
                                scale: obj.scale.clone()
                            };
                            // å¦‚æœå˜æ¢ç¡®å®å‘ç”Ÿï¼ˆä¸ before ä¸åŒï¼‰ï¼Œåˆ™æ¨å…¥ undo
                            const before = this._transformBefore;
                            const changed = !before.position.equals(after.position) ||
                                            !before.rotation.equals(after.rotation) ||
                                            !before.scale.equals(after.scale);
                            if (changed && !this._suppressUndo) {
                                this._pushUndo({
                                    type: 'transform',
                                    id: before.id,
                                    before,
                                    after
                                });
                            }
                        }
                        this._transformBefore = null;
                    }
                } catch (e) {
                    // ignore transform undo recording errors
                }
            });
            this.transformControls.addEventListener('change', () => {
                // åœ¨å˜æ¢è¿‡ç¨‹ä¸­åˆ·æ–°/ä¿æŒé€‰ä¸­é«˜äº®
                try { this._updateSelectionHelper(); } catch (e) { /* ignore */ }
                // ç­‰æ¯”ä¾‹ç¼©æ”¾å¤„ç†
                if (this.transformControls && this.uniformScale && this.transformControls.getMode() === 'scale' && this.transformControls.object) {
                    if (this._applyingUniformScale) return;
                    try {
                        this._applyingUniformScale = true;
                        const obj = this.transformControls.object;
                        // ä½¿ç”¨ä¸‰è½´å¹³å‡å€¼ä½œä¸ºç»Ÿä¸€ç¼©æ”¾å› å­
                        const sx = obj.scale.x, sy = obj.scale.y, sz = obj.scale.z;
                        const s = (sx + sy + sz) / 3;
                        obj.scale.set(s, s, s);
                    } catch (e) {
                        // ignore
                    } finally {
                        this._applyingUniformScale = false;
                    }
                }
            });
            this.transformControls.visible = false;
            this.scene.add(this.transformControls);
        } catch (e) {
            console.warn('TransformControls åˆå§‹åŒ–å¤±è´¥:', e);
            this.transformControls = null;
        }
        this.transformEnabled = false;
        this.uniformScale = false;
        this._applyingUniformScale = false;

        // çª—å£å¤§å°æ”¹å˜æ—¶è°ƒæ•´
        window.addEventListener('resize', () => this.onWindowResize());

        // é»˜è®¤çš„ 35mm ä¼ æ„Ÿå™¨é«˜åº¦ï¼ˆç”¨äºç„¦è·<->FOV çš„æ¢ç®—ï¼‰
        this._sensorHeightMm = 24.0;
    }

    setupAuxView() {
        // åˆå§‹åŒ–è¾…åŠ©è§†å›¾
        const auxContainer = document.getElementById('auxViewer');
        const auxViewContainer = document.getElementById('auxViewContainer');
        if (!auxContainer || !auxViewContainer) {
            console.warn('æ‰¾ä¸åˆ°è¾…åŠ©è§†å›¾å®¹å™¨');
            return;
        }

        // åˆ›å»ºè¾…åŠ©ç›¸æœºï¼ˆä½¿ç”¨ä¸ä¸»ç›¸æœºç›¸åŒçš„å‚æ•°ï¼‰
        this.auxCamera = new THREE.PerspectiveCamera(75, 200/150, 0.1, 1000);
        this.auxCamera.position.set(5, 5, 5);

        // åˆ›å»ºè¾…åŠ©æ¸²æŸ“å™¨
        this.auxRenderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
        this.auxRenderer.setSize(200, 150);
        this.auxRenderer.setPixelRatio(1); // è¾…åŠ©è§†å›¾ä¸éœ€è¦é«˜DPI
        this.auxRenderer.shadowMap.enabled = true;
        this.auxRenderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // åº”ç”¨ç›¸åŒçš„tone mappingè®¾ç½®
        try {
            this.auxRenderer.toneMapping = THREE.ACESFilmicToneMapping;
            this.auxRenderer.toneMappingExposure = 1;
        } catch (e) {}

        auxContainer.appendChild(this.auxRenderer.domElement);

        // æ·»åŠ resizeç›‘å¬å™¨
        this.setupAuxViewResizeObserver(auxViewContainer);

        console.log('è¾…åŠ©è§†å›¾åˆå§‹åŒ–æˆåŠŸ');
    }

    setupAuxViewResizeObserver(auxViewContainer) {
        // ä½¿ç”¨ResizeObserverç›‘å¬å®¹å™¨å¤§å°å˜åŒ–
        if (window.ResizeObserver) {
            this.auxViewResizeObserver = new ResizeObserver((entries) => {
                for (let entry of entries) {
                    const { width, height } = entry.contentRect;
                    this.updateAuxViewSize(width, height);
                }
            });
            this.auxViewResizeObserver.observe(auxViewContainer);
        } else {
            // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨å®šæ—¶å™¨æ£€æµ‹å¤§å°å˜åŒ–
            this.auxViewLastSize = { width: 200, height: 150 };
            this.auxViewResizeInterval = setInterval(() => {
                const rect = auxViewContainer.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height - 28; // å‡å»headeré«˜åº¦

                if (width !== this.auxViewLastSize.width || height !== this.auxViewLastSize.height) {
                    this.updateAuxViewSize(width, height);
                    this.auxViewLastSize = { width, height };
                }
            }, 100);
        }
    }

    updateAuxViewSize(width, height) {
        if (!this.auxRenderer || !this.auxCamera) return;

        // æ›´æ–°æ¸²æŸ“å™¨å°ºå¯¸
        this.auxRenderer.setSize(width, height);

        // æ›´æ–°ç›¸æœºaspect ratio
        this.auxCamera.aspect = width / height;
        this.auxCamera.updateProjectionMatrix();

        console.log(`è¾…åŠ©è§†å›¾å°ºå¯¸æ›´æ–°: ${width}x${height}`);
    }

    setupLoaders() {
        // OBJåŠ è½½å™¨
        this.loaders.obj = new THREE.OBJLoader();

        // FBXåŠ è½½å™¨
        try {
            this.loaders.fbx = new THREE.FBXLoader();
            console.log('FBXåŠ è½½å™¨åˆå§‹åŒ–æˆåŠŸ');
        } catch (error) {
            console.warn('FBXåŠ è½½å™¨åˆå§‹åŒ–å¤±è´¥:', error);
            this.loaders.fbx = null;
        }

        // GLTF/GLBåŠ è½½å™¨
        this.loaders.gltf = new THREE.GLTFLoader();

        // ColladaåŠ è½½å™¨
        this.loaders.dae = new THREE.ColladaLoader();

        // PLYåŠ è½½å™¨
        this.loaders.ply = new THREE.PLYLoader();

        // STLåŠ è½½å™¨
        this.loaders.stl = new THREE.STLLoader();

        // çº¹ç†åŠ è½½å™¨
        this.loaders.texture = new THREE.TextureLoader();
    }

    setupLights() {
        // ç¯å¢ƒå…‰
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        this.scene.add(ambientLight);
        this.lights.push(ambientLight);
        this.ambientLight = ambientLight;

        // åŠçƒå…‰ï¼ˆè¡¥å……ç¯å¢ƒå…‰ï¼Œä½¿æ²¡æœ‰æ–¹å‘å…‰æ—¶åœºæ™¯ä»èƒ½è¢«ç…§äº®ï¼‰
        try {
            this.hemiLight = new THREE.HemisphereLight(0x888877, 0x444455, 0.4);
            this.scene.add(this.hemiLight);
            this.lights.push(this.hemiLight);
        } catch (e) {
            this.hemiLight = null;
        }

        // æ–¹å‘å…‰
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        // å°†ç›®æ ‡æ·»åŠ åˆ°åœºæ™¯ä»¥ç¡®ä¿æ–¹å‘å…‰å¯¹å‡†å·¥ä½œ
        this.scene.add(directionalLight);
        this.scene.add(directionalLight.target);
        this.lights.push(directionalLight);
        this.directionalLight = directionalLight;
        // åˆ›å»ºä¸€ä¸ªäº¤äº’å¼çš„å…‰æ ‡ï¼ˆå¯æ‹–æ‹½ï¼‰ç”¨äºè°ƒæ•´æ–¹å‘å…‰ä½ç½®
        try {
            const helperGeom = new THREE.SphereGeometry(0.15, 16, 16);
            const helperMat = new THREE.MeshBasicMaterial({ color: 0xffee88 });
            const helperMesh = new THREE.Mesh(helperGeom, helperMat);
            helperMesh.position.copy(directionalLight.position);
            helperMesh.name = 'directionalLightHelper';
            this.scene.add(helperMesh);
            this.lightHelper = helperMesh;
            // å°†é»˜è®¤æ–¹å‘å…‰ä¹ŸåŠ å…¥ userLightsï¼Œä¾¿äºç»Ÿä¸€ç®¡ç†
            const id = `light-${this.lightIdCounter++}`;
            this.userLights[id] = { light: directionalLight, helper: helperMesh, type: 'directional', id };
            // åˆ›å»ºUIé¡¹ï¼ˆå¦‚æœé¡µé¢å·²åŠ è½½ï¼‰
            if (typeof createLightUI === 'function') createLightUI(id, 'æ–¹å‘å…‰', directionalLight.intensity, '#ffffff');
        } catch (e) {
            console.warn('åˆ›å»ºå…‰æ ‡å¤±è´¥', e);
            this.lightHelper = null;
        }

        // ä¸ä½¿ç”¨å…¨å±€ç‚¹å…‰ï¼ˆç‚¹å…‰å·²ç§»é™¤ï¼Œç”¨æˆ·å¯åˆ›å»ºè‡ªå®šä¹‰ç‚¹å…‰ï¼‰
    }


    setupHelpers() {
        // åœ°é¢ç½‘æ ¼
        // æ¢å¤ä¸ºåŸå§‹çš„åœ°é¢ç½‘æ ¼
        try {
            this.gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
            this.gridHelper.visible = true;
            this.scene.add(this.gridHelper);
        } catch (e) {
            console.warn('åˆ›å»ºåœ°é¢ç½‘æ ¼å¤±è´¥', e);
            this.gridHelper = null;
        }

        // åæ ‡è½´è¾…åŠ©å™¨
        this.axesHelper = new THREE.AxesHelper(5);
        this.axesHelper.visible = false;
        this.scene.add(this.axesHelper);
    }

    // åŠ è½½ HDR/EXR æˆ–æ™®é€šå›¾ç‰‡ä½œä¸ºç¯å¢ƒè´´å›¾ï¼ˆå¹¶è®¾ç½®ä¸º scene.environmentï¼‰
    loadEnvironmentFromFile(file) {
        const url = URL.createObjectURL(file);
        this.showLoading();

        const finishWithEnv = (envMap, disposeSource) => {
            try {
                // æ¸…ç†ä¹‹å‰çš„ environment
                if (this._currentEnvMap && this._currentEnvMap !== envMap) {
                    try { this._currentEnvMap.dispose(); } catch (e) {}
                }
                this._currentEnvMap = envMap;
                this.scene.environment = envMap;
                // åŒæ­¥ä½œä¸ºèƒŒæ™¯ï¼ˆå¯æ”¹ä¸º null å¦‚æœä¸æƒ³æ˜¾ç¤ºèƒŒæ™¯ï¼‰
                this.scene.background = envMap;
                this.hideLoading();
                this.showMessage('ç¯å¢ƒè´´å›¾å·²åŠ è½½: ' + file.name, 'success');
                // ç¦ç”¨é¢œè‰²æ§ä»¶ä»¥é¿å…ä¸ HDRI å†²çª
                try {
                    const colorEl = document.getElementById('envColorPicker');
                    const intensityEl = document.getElementById('envColorIntensity');
                    if (colorEl) colorEl.disabled = true;
                    if (intensityEl) intensityEl.disabled = true;
                    const statusEl = document.getElementById('hdriStatus');
                    if (statusEl) statusEl.textContent = 'å·²åŠ è½½: ' + file.name;
                } catch (e) {}
            } catch (e) {
                console.error('è®¾ç½®ç¯å¢ƒè´´å›¾å¤±è´¥', e);
                this.hideLoading();
                this.showMessage('è®¾ç½®ç¯å¢ƒè´´å›¾å¤±è´¥', 'error');
            } finally {
                if (disposeSource) {
                    try { disposeSource.dispose(); } catch (e) {}
                }
                try { URL.revokeObjectURL(url); } catch (e) {}
            }
        };

        const onError = (err) => {
            console.error('ç¯å¢ƒè´´å›¾åŠ è½½å¤±è´¥', err);
            this.hideLoading();
            try { URL.revokeObjectURL(url); } catch (e) {}
            this.showMessage('ç¯å¢ƒè´´å›¾åŠ è½½å¤±è´¥: ' + file.name, 'error');
        };

        try {
            const lower = (file.name || '').toLowerCase();
            if (lower.endsWith('.hdr')) {
                // ä½¿ç”¨ RGBELoader åŠ è½½ HDR
                const rgbe = new THREE.RGBELoader();
                rgbe.setDataType(THREE.UnsignedByteType);
                rgbe.load(url, (texture) => {
                    const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                    pmremGenerator.compileEquirectangularShader();
                    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                    finishWithEnv(envMap, null);
                    pmremGenerator.dispose();
                }, null, onError);
            } else if (lower.endsWith('.exr')) {
                // ä½¿ç”¨ EXRLoader åŠ è½½ EXR
                const exrLoader = new THREE.EXRLoader();
                exrLoader.load(url, (texture) => {
                    const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                    pmremGenerator.compileEquirectangularShader();
                    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                    finishWithEnv(envMap, null);
                    pmremGenerator.dispose();
                }, null, onError);
            } else {
                // å…¶ä»–å›¾ç‰‡å½“ä½œç­‰è·è´´å›¾å¤„ç†
                if (this.loaders && this.loaders.texture) {
                    this.loaders.texture.load(url, (texture) => {
                        const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                        pmremGenerator.compileEquirectangularShader();
                        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                        finishWithEnv(envMap, null);
                        pmremGenerator.dispose();
                    }, null, onError);
                } else {
                    // åå¤‡ï¼šImage -> Texture
                    const img = new Image();
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                        pmremGenerator.compileEquirectangularShader();
                        const envMap = pmremGenerator.fromEquirectangular(tex).texture;
                        finishWithEnv(envMap, null);
                        pmremGenerator.dispose();
                    };
                    img.onerror = onError;
                    img.src = url;
                }
            }
        } catch (e) {
            onError(e);
        }
    }

    // ä½¿ç”¨å•è‰²ä½œä¸ºç¯å¢ƒå…‰ï¼ˆé€šè¿‡è°ƒæ•´ç¯å¢ƒå…‰/åŠçƒå…‰å¼ºåº¦å’Œé¢œè‰²å®ç°ï¼‰
    setEnvironmentColor(hex, intensity = 1.0) {
        try {
            // æ¸…é™¤ç°æœ‰ environment ç¯å¢ƒè´´å›¾
            if (this._currentEnvMap) {
                try { this._currentEnvMap.dispose(); } catch (e) {}
                this._currentEnvMap = null;
            }
            this.scene.environment = null;
            // æ›´æ–°æ¸²æŸ“èƒŒæ™¯ä¸ºçº¯è‰²
            const container = document.getElementById('viewer');
            if (container) container.style.background = hex;

            // è®¾ç½®ç¯å¢ƒå…‰ä¸åŠçƒå…‰é¢œè‰²/å¼ºåº¦
            if (this.ambientLight) {
                this.ambientLight.color.set(hex);
                this.ambientLight.intensity = Number(intensity);
            }
            if (this.hemiLight) {
                this.hemiLight.color.set(hex);
                this.hemiLight.intensity = Math.max(0, Number(intensity) * 0.6);
            }
            // è§¦å‘æè´¨æ›´æ–°
            this.models.forEach(model => {
                if (model.object) {
                    model.object.traverse((child) => {
                        if (child.isMesh && child.material) {
                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            materials.forEach(mat => { mat.needsUpdate = true; });
                        }
                    });
                }
            });
            this.showMessage('ç¯å¢ƒè‰²å·²è®¾ç½®: ' + hex, 'success');
        } catch (e) {
            console.error('è®¾ç½®ç¯å¢ƒè‰²å¤±è´¥', e);
            this.showMessage('è®¾ç½®ç¯å¢ƒè‰²å¤±è´¥', 'error');
        }
    }

    // HDRI å˜æ¢åŠŸèƒ½å·²ç§»é™¤ï¼ˆä¿æŒåŠ è½½ä¸æ˜¾ç¤º/éšè—ï¼‰
    setupEventListeners() {
        // æ–‡ä»¶æ‹–æ‹½ä¸Šä¼ 
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            this.loadFiles(files);
        });

        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            this.loadFiles(files);
        });
        // æ¸…ç©º fileInput çš„å€¼ä»¥å…è®¸é‡å¤é€‰æ‹©ç›¸åŒæ–‡ä»¶ï¼ˆæµè§ˆå™¨åœ¨é€‰æ‹©åŒä¸€è·¯å¾„æ–‡ä»¶æ—¶å¯èƒ½ä¸ä¼šè§¦å‘ changeï¼‰
        fileInput.addEventListener('change', (e) => {
            try { e.target.value = ''; } catch (ex) { /* ignore */ }
        });

        // HDRI ä¸Šä¼ ç›‘å¬ï¼ˆç¯å¢ƒç…§æ˜ï¼‰
        const hdriInput = document.getElementById('hdriInput');
        if (hdriInput) {
            hdriInput.addEventListener('change', (e) => {
                const file = e.target.files && e.target.files[0];
                if (file) {
                    try {
                        this.loadEnvironmentFromFile(file);
                        const statusEl = document.getElementById('hdriStatus');
                        if (statusEl) statusEl.textContent = 'å·²åŠ è½½: ' + file.name;
                    } catch (err) {
                        console.error('åŠ è½½ HDRI å¤±è´¥', err);
                        this.showMessage('åŠ è½½ HDRI å¤±è´¥', 'error');
                    }
                }
                try { e.target.value = ''; } catch (ex) { /* ignore */ }
            });
        }

        // æŒ‡é’ˆæ‹–æ‹½äº‹ä»¶ï¼šç”¨äºäº¤äº’å¼è°ƒæ•´æ–¹å‘å…‰ä½ç½®
        this.raycaster = new THREE.Raycaster();
        this.pointer = new THREE.Vector2();
        this.dragPlane = new THREE.Plane();
        this.dragOffset = new THREE.Vector3();

        const canvas = this.renderer.domElement;
        canvas.style.touchAction = 'none';
        canvas.addEventListener('pointerdown', (e) => this._onPointerDown(e));
        canvas.addEventListener('pointermove', (e) => this._onPointerMove(e));
        window.addEventListener('pointerup', (e) => this._onPointerUp(e));
        // åœ¨æ‰€æœ‰äº¤äº’ç›‘å¬ä¹‹åå¢åŠ ä¸€ä¸ªç”¨äºå–æ¶ˆé€‰æ‹©çš„ç‚¹å‡»ç›‘å¬
        canvas.addEventListener('pointerdown', (e) => this._onCanvasPointerDown(e));
        canvas.addEventListener('pointerup', (e) => this._onCanvasPointerUp(e));
        // é”®ç›˜ç›‘å¬ï¼šDeleteé”®åˆ é™¤é€‰ä¸­æ¨¡å‹æˆ–ç¯å…‰
        window.addEventListener('keydown', (e) => {
            // Ctrl+Z / Cmd+Z æ’¤é”€
            if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')) {
                const active = document.activeElement;
                if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;
                this.undo();
                e.preventDefault();
                return;
            }
            if (e.key === 'Delete' || e.key === 'Del' || e.key === 'Backspace') {
                // å¦‚æœæ­£åœ¨è¾“å…¥æ–‡æœ¬ï¼Œå¿½ç•¥
                const active = document.activeElement;
                if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;
                this._handleDeleteKey();
            }
        });
    }

    loadFiles(files) {
        files.forEach(file => {
            // If it's an image, load as image plane; otherwise treat as model
            if (file && file.type && file.type.startsWith('image/')) {
                this.loadImageAsPlane(file);
            } else {
                const extension = file.name.split('.').pop().toLowerCase();
                this.loadModel(file, extension);
            }
        });
    }

    loadModel(file, extension) {
        this.loadModelWithTransform(file, extension, null, null);
    }

    loadModelWithTransform(file, extension, transformData, onComplete) {
        const url = URL.createObjectURL(file);

        this.showLoading();

        const onLoad = (object) => {
            this.hideLoading();

            // å¦‚æœæœ‰å˜æ¢æ•°æ®ï¼Œåœ¨æ·»åŠ åˆ°åœºæ™¯å‰åº”ç”¨
            if (transformData) {
                // åº”ç”¨ä¿å­˜çš„å˜æ¢ä¿¡æ¯
                if (transformData.position) {
                    object.position.fromArray(transformData.position);
                }
                if (transformData.rotation) {
                    object.rotation.fromArray(transformData.rotation);
                }
                if (transformData.scale) {
                    object.scale.fromArray(transformData.scale);
                }
                if (transformData.visible !== undefined) {
                    object.visible = transformData.visible;
                }
                if (transformData.userData) {
                    object.userData = { ...object.userData, ...transformData.userData };
                }

                // æ·»åŠ åˆ°åœºæ™¯ï¼ˆä¸åº”ç”¨è‡ªåŠ¨ç¼©æ”¾å’Œå¯¹é½ï¼‰
                this.addModelToSceneWithoutAutoTransform(object, file.name, file);
            } else {
                // æ­£å¸¸åŠ è½½
                this.addModelToScene(object, file.name, file);
            }

            URL.revokeObjectURL(url);
            this.showMessage('æ¨¡å‹åŠ è½½æˆåŠŸ: ' + file.name, 'success');

            if (onComplete) onComplete();
        };

        const onError = (error) => {
            this.hideLoading();
            console.error('åŠ è½½å¤±è´¥:', error);
            this.showMessage('åŠ è½½å¤±è´¥: ' + file.name, 'error');
            URL.revokeObjectURL(url);
            if (onComplete) onComplete();
        };

        switch (extension) {
            case 'obj':
                this.loaders.obj.load(url, onLoad, null, onError);
                break;
            case 'fbx':
                try {
                    console.log('å¼€å§‹åŠ è½½FBXæ–‡ä»¶:', file.name);
                    this.loaders.fbx.load(url, onLoad, function(progress) {
                        console.log('FBXåŠ è½½è¿›åº¦:', (progress.loaded / progress.total * 100) + '%');
                    }, function(error) {
                        console.error('FBXåŠ è½½é”™è¯¯:', error);
                        // æä¾›æ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
                        let errorMsg = 'FBXåŠ è½½å¤±è´¥';
                        if (error && error.message) {
                            if (error.message.includes('Unsupported file type')) {
                                errorMsg = 'ä¸æ”¯æŒçš„FBXæ–‡ä»¶æ ¼å¼ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ˜¯ä»3Dè½¯ä»¶æ­£ç¡®å¯¼å‡ºçš„é™æ€æ¨¡å‹';
                            } else if (error.message.includes('corrupt') || error.message.includes('invalid')) {
                                errorMsg = 'FBXæ–‡ä»¶æ ¼å¼é”™è¯¯æˆ–å·²æŸå';
                            } else {
                                errorMsg = 'FBXåŠ è½½å¤±è´¥: ' + error.message;
                            }
                        } else if (error) {
                            errorMsg = 'FBXåŠ è½½å¤±è´¥: ' + error;
                        }
                        onError(new Error(errorMsg));
                    });
                } catch (error) {
                    console.error('FBXåŠ è½½å™¨å¼‚å¸¸:', error);
                    onError(new Error('FBXæ ¼å¼ä¸æ”¯æŒï¼Œè¯·å°è¯•å…¶ä»–æ ¼å¼æˆ–æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºé™æ€3Dæ¨¡å‹'));
                }
                break;
            case 'glb':
            case 'gltf':
                this.loaders.gltf.load(url, (gltf) => onLoad(gltf.scene), null, onError);
                break;
            case 'dae':
                this.loaders.dae.load(url, (collada) => onLoad(collada.scene), null, onError);
                break;
            case 'ply':
                this.loaders.ply.load(url, (geometry) => {
                    const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
                    const mesh = new THREE.Mesh(geometry, material);
                    onLoad(mesh);
                }, null, onError);
                break;
            case 'stl':
                this.loaders.stl.load(url, (geometry) => {
                    const material = new THREE.MeshLambertMaterial({ color: 0xff6600 });
                    const mesh = new THREE.Mesh(geometry, material);
                    onLoad(mesh);
                }, null, onError);
                break;
            case '3ds':
                // 3DSæ ¼å¼éœ€è¦é¢å¤–çš„åŠ è½½å™¨ï¼Œè¿™é‡Œæš‚æ—¶ä¸æ”¯æŒ
                this.showMessage('3DSæ ¼å¼æš‚ä¸æ”¯æŒ', 'error');
                break;
            default:
                this.showMessage('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: ' + extension, 'error');
        }
    }

    // å°†å›¾ç‰‡ä½œä¸ºå¹³é¢åŠ è½½åˆ°åœºæ™¯ï¼ˆåƒæ¨¡å‹ä¸€æ ·ï¼‰
    loadImageAsPlane(file) {
        const url = URL.createObjectURL(file);
        this.showLoading();

        const onTextureLoad = (texture) => {
            try {
                // æ ¹æ®å›¾ç‰‡å®½é«˜åˆ›å»ºå¹³é¢å‡ ä½•ï¼Œè®¾ç½®åˆç†çš„å°ºå¯¸ï¼ˆæœ€å¤§è¾¹é•¿çº¦ä¸º2å•ä½ï¼‰
                const image = texture.image;
                const aspect = (image && image.width && image.height) ? (image.width / image.height) : 1;
                const maxSize = 2.0;
                let width = maxSize;
                let height = maxSize;
                if (aspect >= 1) {
                    width = maxSize;
                    height = maxSize / aspect;
                } else {
                    width = maxSize * aspect;
                    height = maxSize;
                }

                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = file.name;
                // è½»å¾®æŠ¬é«˜ä»¥é¿å…ä¸åœ°é¢ç½‘æ ¼é‡å 
                mesh.position.set(0, height / 2, 0);
                // å°†å›¾ç‰‡å¹³é¢ä½œä¸ºä¸€ä¸ªâ€œæ¨¡å‹â€åŠ å…¥åœºæ™¯ï¼Œå¤ç”¨ addModelToScene æ³¨å†Œé€»è¾‘
                this.hideLoading();
                this.addModelToScene(mesh, file.name, file);
                URL.revokeObjectURL(url);
                this.showMessage('å›¾ç‰‡å·²åŠ è½½ä¸ºå¹³é¢: ' + file.name, 'success');
            } catch (e) {
                console.error('åˆ›å»ºå›¾ç‰‡å¹³é¢å¤±è´¥', e);
                this.hideLoading();
                URL.revokeObjectURL(url);
                this.showMessage('å›¾ç‰‡åŠ è½½å¤±è´¥: ' + file.name, 'error');
            }
        };

        const onError = (err) => {
            console.error('å›¾ç‰‡çº¹ç†åŠ è½½å¤±è´¥', err);
            this.hideLoading();
            URL.revokeObjectURL(url);
            this.showMessage('å›¾ç‰‡åŠ è½½å¤±è´¥: ' + file.name, 'error');
        };

        try {
            if (this.loaders && this.loaders.texture) {
                this.loaders.texture.load(url, onTextureLoad, null, onError);
            } else {
                // ä½œä¸ºåå¤‡ä½¿ç”¨ Image + Texture æ„é€ 
                const img = new Image();
                img.onload = () => {
                    const tex = new THREE.Texture(img);
                    tex.needsUpdate = true;
                    onTextureLoad(tex);
                };
                img.onerror = onError;
                img.src = url;
            }
        } catch (e) {
            onError(e);
        }
    }

    addModelToScene(object, fileName, fileBlob) {
        // è®¾ç½®æ¨¡å‹å±æ€§
        object.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // ç¡®ä¿æè´¨æ­£ç¡®
                if (child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                            mat.needsUpdate = true;

                        // å¯¹äº PBR æè´¨ï¼Œç¡®ä¿ç¯å¢ƒå…‰ç…§å¼ºåº¦æ­£ç¡®è®¾ç½®ï¼ˆä»…è°ƒæ•´ envMapIntensityï¼Œä¸ä¿®æ”¹ emissiveï¼‰
                        if (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial) {
                            if (mat.envMapIntensity === undefined || mat.envMapIntensity === 0) {
                                const ambientIntensity = this.ambientLight ? this.ambientLight.intensity : 0.6;
                                mat.envMapIntensity = Math.max(0.1, ambientIntensity * 0.5);
                    }
                        }
                        // ä¸åœ¨æ­¤å¤„ä¿®æ”¹ä¼ ç»Ÿæè´¨çš„ emissiveï¼Œé¿å…æœªé€‰ä¸­æ—¶å‡ºç°ç±»ä¼¼é«˜äº®çš„æ•ˆæœ
                    });
                }
            }
        });

        // è®¡ç®—è¾¹ç•Œæ¡†ä»¥å±…ä¸­å’Œç¼©æ”¾
        const box = new THREE.Box3().setFromObject(object);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        // å±…ä¸­æ¨¡å‹
        object.position.sub(center);

        // ç¼©æ”¾åˆ°ç›®æ ‡å¤§å°ï¼ˆå°†æ¨¡å‹çš„æœ€å¤§è¾¹ç¼©æ”¾åˆ° this.modelTargetSizeï¼‰
        const maxDim = Math.max(size.x, size.y, size.z);
        if (maxDim > 0) {
            const scale = this.modelTargetSize / maxDim;
            object.scale.multiplyScalar(scale);
        }

        // æ·»åŠ åˆ°åœºæ™¯
        this.scene.add(object);

        // å¦‚æœå¯ç”¨äº†ç»Ÿä¸€å¯¹é½ï¼ˆé»˜è®¤ï¼‰ï¼ŒæŠŠæ¨¡å‹ç»Ÿä¸€ç¼©æ”¾å¹¶ä¸”åŸºåº•å¯¹é½åˆ°åœ°é¢(y=0)ï¼Œåœ¨ XZ å¹³é¢å°†ä¸­å¿ƒå¯¹é½åˆ° controls.target.xz
        if (this.uniformAlign) {
            const desiredXZ = this.controls ? new THREE.Vector3(this.controls.target.x, 0, this.controls.target.z) : new THREE.Vector3(0, 0, 0);
            // 1) è®¡ç®—åŸå§‹ bbox å¹¶æŠŠå…¶ä¸­å¿ƒç§»åˆ°åŸç‚¹ï¼ˆä¿è¯ç¼©æ”¾ä»¥æ¨¡å‹ä¸­å¿ƒä¸ºåŸºå‡†ï¼‰
            const box = new THREE.Box3().setFromObject(object);
            const objCenter = box.getCenter(new THREE.Vector3());
            object.position.sub(objCenter);
            // 2) ç»Ÿä¸€ç¼©æ”¾
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim > 0) {
                const scale = this.modelTargetSize / maxDim;
                object.scale.set(scale, scale, scale);
            }
            // 3) é‡æ–°è®¡ç®— bbox å¹¶æŠŠæ¨¡å‹æ”¾åˆ° desiredXZï¼Œä¸”å°† bbox.min.y å¯¹é½åˆ° y=0ï¼ˆåœ°é¢ï¼‰
            const boxAfter = new THREE.Box3().setFromObject(object);
            const centerAfter = boxAfter.getCenter(new THREE.Vector3());
            const minY = boxAfter.min.y;
            const translation = new THREE.Vector3(desiredXZ.x - centerAfter.x, -minY, desiredXZ.z - centerAfter.z);
            object.position.add(translation);
        } else {
            // è‡ªåŠ¨æ’åˆ—ï¼šè®¡ç®—æ”¾ç½®ä½ç½®ï¼Œé¿å…ä¸å·²æœ‰æ¨¡å‹é‡å 
            const index = this.models.length; // åœ¨åŠ å…¥å‰çš„ç´¢å¼•
            const offset = this._getNextModelPosition(index);
            object.position.add(offset);
        }

        // ç”Ÿæˆæ¨¡å‹ id å¹¶åŠ å…¥æ¨¡å‹åˆ—è¡¨
        const modelId = `model-${Date.now()}-${this.models.length}`;
        object.userData._modelId = modelId;
        this.models.push({ id: modelId, name: fileName, file: fileBlob || null, fileName: fileName, object, visible: true });
        // é»˜è®¤ä¸è‡ªåŠ¨é€‰ä¸­æ–°åŠ è½½çš„æ¨¡å‹ï¼Œä¿æŒç”¨æˆ·å½“å‰é€‰æ‹©ä¸å˜

        // è®°å½• undo: æ·»åŠ æ¨¡å‹ï¼ˆæ’¤é”€æ—¶åˆ é™¤å®ƒï¼‰
        if (!this._suppressUndo) {
            this._pushUndo({ type: 'addModel', id: modelId });
        }

        // æ›´æ–°æ–‡ä»¶åˆ—è¡¨
        this.updateFileList(fileName);

        // æ ‡è®°æœ‰æœªä¿å­˜çš„æ›´æ”¹
        this.markUnsavedChanges();

        // æ›´æ–°æ¨¡å‹ä¿¡æ¯
        this.updateModelInfo(object, size, fileName);

        // è°ƒæ•´ç›¸æœºä»¥æ˜¾ç¤ºæ‰€æœ‰æ¨¡å‹ï¼ˆé¿å…æ–°æ¨¡å‹è¦†ç›–æ—§æ¨¡å‹çœ‹ä¸è§ï¼‰
        this.fitToAllModels();
        // è®°å½•æ·»åŠ æ¨¡å‹åˆ°å†å²ï¼ˆæ”¯æŒæ’¤é”€ï¼šåˆ é™¤è¯¥æ¨¡å‹ï¼‰
        const addedModelRef = { id: modelId, name: fileName, object };
        this.pushHistory({
            undo: () => {
                // remove silently
                this.removeModelSilent(addedModelRef.id);
            },
            redo: () => {
                // re-add silently
                this.addModelSilent(addedModelRef);
            }
        });
    }

    addModelToSceneWithoutAutoTransform(object, fileName, fileBlob) {
        // è®¾ç½®æ¨¡å‹å±æ€§ï¼ˆä¸addModelToSceneç›¸åŒï¼‰
        object.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // ç¡®ä¿æè´¨æ­£ç¡®
                if (child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                            mat.needsUpdate = true;

                        // å¯¹äº PBR æè´¨ï¼Œç¡®ä¿ç¯å¢ƒå…‰ç…§å¼ºåº¦æ­£ç¡®è®¾ç½®ï¼ˆä»…è°ƒæ•´ envMapIntensityï¼Œä¸ä¿®æ”¹ emissiveï¼‰
                        if (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial) {
                            if (mat.envMapIntensity === undefined || mat.envMapIntensity === 0) {
                                const ambientIntensity = this.ambientLight ? this.ambientLight.intensity : 0.6;
                                mat.envMapIntensity = Math.max(0.1, ambientIntensity * 0.5);
                    }
                        }
                        // ä¸åœ¨æ­¤å¤„ä¿®æ”¹ä¼ ç»Ÿæè´¨çš„ emissiveï¼Œé¿å…æœªé€‰ä¸­æ—¶å‡ºç°ç±»ä¼¼é«˜äº®çš„æ•ˆæœ
                    });
                }
            }
        });

        // æ·»åŠ åˆ°åœºæ™¯ï¼ˆä¸è¿›è¡Œå±…ä¸­ã€ç¼©æ”¾ã€å¯¹é½ç­‰è‡ªåŠ¨å˜æ¢ï¼‰
        this.scene.add(object);

        // ç”Ÿæˆæ¨¡å‹ id å¹¶åŠ å…¥æ¨¡å‹åˆ—è¡¨
        const modelId = `model-${Date.now()}-${this.models.length}`;
        object.userData._modelId = modelId;
        this.models.push({ id: modelId, name: fileName, file: fileBlob || null, fileName: fileName, object, visible: true });

        // è®°å½• undo: æ·»åŠ æ¨¡å‹ï¼ˆæ’¤é”€æ—¶åˆ é™¤å®ƒï¼‰
        if (!this._suppressUndo) {
            this._pushUndo({ type: 'addModel', id: modelId });
        }

        // æ›´æ–°æ–‡ä»¶åˆ—è¡¨
        this.updateFileList(fileName);

        // æ ‡è®°æœ‰æœªä¿å­˜çš„æ›´æ”¹
        this.markUnsavedChanges();

        // è®¡ç®—åŸå§‹å°ºå¯¸ç”¨äºæ˜¾ç¤º
        const box = new THREE.Box3().setFromObject(object);
        const size = box.getSize(new THREE.Vector3());

        // æ›´æ–°æ¨¡å‹ä¿¡æ¯
        this.updateModelInfo(object, size, fileName);

        // è°ƒæ•´ç›¸æœºä»¥æ˜¾ç¤ºæ‰€æœ‰æ¨¡å‹
        this.fitToAllModels();

        // è®°å½•æ·»åŠ æ¨¡å‹åˆ°å†å²
        const addedModelRef = { id: modelId, name: fileName, object };
        this.pushHistory({
            undo: () => {
                this.removeModelSilent(addedModelRef.id);
            },
            redo: () => {
                this.addModelSilent(addedModelRef);
            }
        });
    }

    updateFileList(fileName) {
        // é‡æ–°æ¸²æŸ“æ•´ä¸ªæ–‡ä»¶åˆ—è¡¨ï¼Œä»¥ç¡®ä¿ä¸ this.models åŒæ­¥
        const fileList = document.getElementById('fileListLeft') || document.getElementById('fileList');
        if (!fileList) return;
        fileList.innerHTML = '';
        this.models.forEach((m) => {
            const item = document.createElement('div');
            item.className = 'file-item';
            item.id = `file-${m.id}`;
            item.style.display = 'flex';
            item.style.flexDirection = 'column';
            item.style.alignItems = 'stretch';
            item.style.padding = '12px';
            item.style.marginBottom = '8px';
            item.style.background = 'var(--card-bg)';
            item.style.borderRadius = 'var(--radius-large)';
            item.style.border = '1px solid var(--border-light)';
            item.style.transition = 'all 0.2s ease';
            item.style.cursor = 'pointer';
            item.onmouseenter = () => {
                item.style.boxShadow = 'var(--shadow-hover)';
                item.style.borderColor = 'var(--accent)';
            };
            item.onmouseleave = () => {
                item.style.boxShadow = '';
                item.style.borderColor = 'var(--border-light)';
            };

            const left = document.createElement('div');
            left.style.flex = '1';
            left.innerHTML = `<div style="font-weight:600; color:#323130;">${m.name}</div><div style="font-size:12px;color:var(--muted); margin-bottom:8px;">${m.visible ? 'å¯è§' : 'éšè—'}</div><div class="file-actions" style="display:flex; gap:6px;"></div>`;

            // æŒ‰é’®ï¼ˆæ”¾åœ¨æ–‡ä»¶åä¸‹æ–¹ï¼‰ï¼Œå¯ä»¥æ›¿æ¢ä¸ºå›¾æ ‡
            const actionsWrap = left.querySelector('.file-actions');

            const selectBtn = document.createElement('button');
            selectBtn.className = 'icon-btn';
            selectBtn.title = 'é€‰æ‹©';
            selectBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="#323130" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12h18"/><path d="M12 3v18"/></svg>';
            selectBtn.onclick = () => this.selectModel(m.id);

            const copyBtn = document.createElement('button');
            copyBtn.className = 'icon-btn';
            copyBtn.title = 'å¤åˆ¶';
            copyBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="#323130" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
            copyBtn.onclick = () => this.copyModel(m.id);

            const hideBtn = document.createElement('button');
            hideBtn.className = 'icon-btn';
            hideBtn.title = m.visible ? 'éšè—' : 'æ˜¾ç¤º';
            hideBtn.innerHTML = m.visible ? '<svg viewBox="0 0 24 24" fill="none" stroke="#323130" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8S1 12 1 12z"/><circle cx="12" cy="12" r="3"/></svg>' : '<svg viewBox="0 0 24 24" fill="none" stroke="#323130" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s4-8 10-8 10 8 10 8"/><path d="M2 12s4 8 10 8 10-8 10-8"/><path d="M3 3l18 18"/></svg>';
            hideBtn.onclick = () => { this.toggleModelVisibility(m.id); hideBtn.title = (m.visible ? 'æ˜¾ç¤º' : 'éšè—'); };

            const delBtn = document.createElement('button');
            delBtn.className = 'icon-btn';
            delBtn.title = 'åˆ é™¤';
            delBtn.style.borderColor = '#d13438';
            delBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="#d13438" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg>';
            delBtn.onclick = () => this.removeModel(m.id);

            actionsWrap.appendChild(selectBtn);
            actionsWrap.appendChild(copyBtn);
            actionsWrap.appendChild(hideBtn);
            actionsWrap.appendChild(delBtn);

            item.appendChild(left);
            fileList.appendChild(item);
        });
    }

    // å°†æ“ä½œå‹å…¥ undo æ ˆ
    _pushUndo(action) {
        this.undoStack.push(action);
        if (this.undoStack.length > this.maxUndo) this.undoStack.shift();
    }

    // æ’¤é”€æœ€è¿‘æ“ä½œ
    undo() {
        if (!this.undoStack || this.undoStack.length === 0) return;
        const action = this.undoStack.pop();
        if (!action) return;
        this._suppressUndo = true;
        try {
            switch (action.type) {
                case 'addModel':
                    // åˆ é™¤è¯¥æ¨¡å‹ï¼ˆå·²å­˜åœ¨ï¼‰
                    this.removeModel(action.id);
                    break;
                case 'removeModel':
                    // æ¢å¤æ¨¡å‹å¯¹è±¡
                    if (action.object) {
                        this.scene.add(action.object);
                        // æ¢å¤æ¨¡å‹åˆ—è¡¨ä½ç½®
                        const idx = (action.index !== undefined) ? action.index : this.models.length;
                        action.object.userData._modelId = action.id;
                        this.models.splice(idx, 0, { id: action.id, name: action.name, object: action.object, visible: true });
                        this.updateFileList();
                        this._updateSelectionHelper();
                    }
                    break;
                case 'toggleVisibility':
                    {
                        const entry = this.models.find(m => m.id === action.id);
                        if (entry && entry.object) {
                            entry.object.visible = action.previous;
                            entry.visible = action.previous;
                            this.updateFileList();
                        }
                    }
                    break;
                case 'addLight':
                    this.removeLight(action.id);
                    break;
                case 'removeLight':
                    if (action.entry) {
                        // restore light and helper
                        this.scene.add(action.entry.light);
                        if (action.entry.helper) this.scene.add(action.entry.helper);
                        this.userLights[action.id] = action.entry;
                        if (typeof createLightUI === 'function') createLightUI(action.id, action.entry.type === 'directional' ? 'æ–¹å‘å…‰' : 'ç‚¹å…‰', action.entry.light.intensity, '#ffffff');
                    }
                    break;
                case 'transform':
                    {
                        const entry = this.models.find(m => m.id === action.id);
                        if (entry && entry.object) {
                            entry.object.position.copy(action.before.position);
                            entry.object.rotation.copy(action.before.rotation);
                            entry.object.scale.copy(action.before.scale);
                            this._updateSelectionHelper();
                        }
                    }
                    break;
                default:
                    console.warn('æœªçŸ¥ undo ç±»å‹', action.type);
            }
        } finally {
            this._suppressUndo = false;
        }
    }

    updateModelInfo(object, size, fileName) {
        // æ¨¡å‹ä¿¡æ¯é¢æ¿å·²ç§»é™¤ï¼Œå‡½æ•°ä¿ç•™ä¸ºç©ºä»¥é¿å…æŠ¥é”™
        return;
    }

    fitToView() {
        if (!this.currentModel) return;

        const box = new THREE.Box3().setFromObject(this.currentModel);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        const maxDim = Math.max(size.x, size.y, size.z);
        const distance = maxDim * 1.5;

        this.camera.position.copy(center);
        this.camera.position.x += distance;
        this.camera.position.y += distance * 0.5;
        this.camera.position.z += distance;

        this.camera.lookAt(center);
        this.controls.target.copy(center);
        this.controls.update();
    }

    // æ¨¡å‹ç®¡ç†: é€‰æ‹©æ¨¡å‹
    // suppressScroll: å½“ä»è§†å›¾ç‚¹å‡»æ¨¡å‹æ—¶ä¼  trueï¼Œé¿å…ä¾§æ è‡ªåŠ¨æ»šåŠ¨
    selectModel(id, suppressScroll = false) {
        const entry = this.models.find(m => m.id === id);
        if (!entry) return;
        this.currentModel = entry.object;
        this._updateSelectionHelper();
        // é«˜äº® UIï¼šä»…åœ¨éè§†å›¾è§¦å‘ï¼ˆå³ suppressScroll ä¸º falseï¼‰æ—¶æ»šåŠ¨åˆ°ä¾§æ æ¡ç›®
        if (!suppressScroll) {
        const el = document.getElementById(`file-${id}`);
        if (el && el.scrollIntoView) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        // å¦‚æœ transform å·²å¯ç”¨ï¼Œåˆ‡æ¢åˆ°é€‰ä¸­æ¨¡å‹
        if (this.transformEnabled && this.transformControls) {
            try {
                this.transformControls.attach(this.currentModel);
                this.transformControls.visible = true;
            } catch (e) {
                console.warn('attach transform failed', e);
            }
        }
    }

    // å¤åˆ¶æ¨¡å‹ï¼ˆæ·±æ‹·è´ mesh å‡ ä½•ä¸æè´¨ï¼ŒåŠ å…¥åœºæ™¯å¹¶æ³¨å†Œåˆ°æ¨¡å‹åˆ—è¡¨ï¼‰
    copyModel(id) {
        const entry = this.models.find(m => m.id === id);
        if (!entry || !entry.object) return;

        let clone;

        // æ£€æŸ¥æ˜¯å¦ä¸ºFBXæ¨¡å‹ï¼Œè¿›è¡Œç‰¹æ®Šå¤„ç†
        const isFBXModel = entry.name.toLowerCase().endsWith('.fbx') || entry.fileName && entry.fileName.toLowerCase().endsWith('.fbx');

        if (isFBXModel) {
            // FBXæ¨¡å‹éœ€è¦ç‰¹æ®Šçš„å¤åˆ¶é€»è¾‘
            clone = this._cloneFBXModel(entry.object);
        } else {
            // å…¶ä»–æ ¼å¼ä½¿ç”¨æ ‡å‡†å…‹éš†
            clone = entry.object.clone(true);
        }

        // å¯¹å…‹éš†çš„æ¯ä¸ª meshï¼Œç¡®ä¿å‡ ä½•ä½“å’Œæè´¨è¢«ç‹¬ç«‹å…‹éš†ï¼ˆé¿å…å¼•ç”¨åŸå§‹èµ„æºå¯¼è‡´ä¿®æ”¹äº’ç›¸å½±å“ï¼‰
        clone.traverse((child) => {
            if (child.isMesh) {
                try {
                    if (child.geometry) child.geometry = child.geometry.clone();
                } catch (e) { /* ignore */ }
                try {
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material = child.material.map(mat => mat ? mat.clone() : mat);
                        } else {
                            child.material = child.material.clone();
                        }
                    }
                } catch (e) { /* ignore */ }
            }
        });

        // å¾®å°å¹³ç§»ä»¥åŒºåˆ«åŸä»¶ï¼ˆé¿å…å®Œå…¨é‡å ï¼‰
        clone.position.add(new THREE.Vector3(0.1, 0, 0.1));

        // ç”Ÿæˆå¹¶è®¾ç½®æ–° id
        const newId = `model-${Date.now()}-${this.models.length}`;
        clone.userData._modelId = newId;

        // æ·»åŠ åˆ°åœºæ™¯ä¸æ¨¡å‹åˆ—è¡¨
        this.scene.add(clone);
        this.models.push({ id: newId, name: `${entry.name} (copy)`, object: clone, visible: true });

        // å°†å¤åˆ¶æ“ä½œåŠ å…¥ undo æ ˆï¼ˆæ’¤é”€å°†åˆ é™¤è¯¥å¤åˆ¶ï¼‰
        if (!this._suppressUndo) {
            this._pushUndo({ type: 'addModel', id: newId });
        }

        // æ›´æ–° UI åˆ—è¡¨
        this.updateFileList();
        // é€‰æ‹©æ–°å…‹éš†çš„æ¨¡å‹
        this.selectModel(newId);
    }

    // ä¸“é—¨ç”¨äºå…‹éš†FBXæ¨¡å‹çš„å‡½æ•°
    _cloneFBXModel(originalObject) {
        // åˆ›å»ºæ–°çš„æ ¹å¯¹è±¡
        const clonedRoot = new THREE.Group();
        clonedRoot.name = originalObject.name + '_clone';

        // å¤åˆ¶æ ¹å¯¹è±¡çš„å˜æ¢
        clonedRoot.position.copy(originalObject.position);
        clonedRoot.rotation.copy(originalObject.rotation);
        clonedRoot.scale.copy(originalObject.scale);
        clonedRoot.visible = originalObject.visible;

        // é€’å½’å…‹éš†æ‰€æœ‰å­å¯¹è±¡
        originalObject.traverse((child) => {
            if (child === originalObject) return; // è·³è¿‡æ ¹å¯¹è±¡æœ¬èº«

            let clonedChild;

            if (child.isMesh) {
                // å¯¹äºMeshå¯¹è±¡ï¼Œéœ€è¦æ·±å…‹éš†å‡ ä½•ä½“å’Œæè´¨
                const clonedGeometry = child.geometry ? child.geometry.clone() : null;
                let clonedMaterial;

                if (child.material) {
                    if (Array.isArray(child.material)) {
                        clonedMaterial = child.material.map(mat => mat ? mat.clone() : null);
                    } else {
                        clonedMaterial = child.material.clone();
                    }
                }

                clonedChild = new THREE.Mesh(clonedGeometry, clonedMaterial);
            } else if (child.isGroup || child.isObject3D) {
                // å¯¹äºGroupæˆ–å…¶ä»–Object3Dï¼Œåˆ›å»ºæ–°çš„Group
                clonedChild = new THREE.Group();
            } else {
                // å¯¹äºå…¶ä»–ç±»å‹çš„å¯¹è±¡ï¼Œç›´æ¥å…‹éš†
                clonedChild = child.clone(true);
            }

            if (clonedChild) {
                // å¤åˆ¶å˜æ¢å’Œå±æ€§
                clonedChild.name = child.name;
                clonedChild.position.copy(child.position);
                clonedChild.rotation.copy(child.rotation);
                clonedChild.scale.copy(child.scale);
                clonedChild.visible = child.visible;
                clonedChild.castShadow = child.castShadow;
                clonedChild.receiveShadow = child.receiveShadow;

                // å¤åˆ¶ç”¨æˆ·æ•°æ®
                if (child.userData) {
                    clonedChild.userData = JSON.parse(JSON.stringify(child.userData));
                }

                // å°†å…‹éš†çš„å­å¯¹è±¡æ·»åŠ åˆ°é€‚å½“çš„çˆ¶å¯¹è±¡ä¸­
                const parentInOriginal = child.parent;
                if (parentInOriginal === originalObject) {
                    // ç›´æ¥å­å¯¹è±¡ï¼Œæ·»åŠ åˆ°æ ¹
                    clonedRoot.add(clonedChild);
                } else {
                    // æŸ¥æ‰¾å…‹éš†æ ‘ä¸­å¯¹åº”çš„çˆ¶å¯¹è±¡
                    const clonedParent = this._findClonedParent(clonedRoot, parentInOriginal, originalObject);
                    if (clonedParent) {
                        clonedParent.add(clonedChild);
                    } else {
                        clonedRoot.add(clonedChild);
                    }
                }
            }
        });

        return clonedRoot;
    }

    // åœ¨å…‹éš†æ ‘ä¸­æŸ¥æ‰¾å¯¹åº”çš„çˆ¶å¯¹è±¡
    _findClonedParent(clonedRoot, originalParent, originalRoot) {
        if (originalParent === originalRoot) return clonedRoot;

        // é€šè¿‡éå†å…‹éš†æ ‘æ¥æ‰¾åˆ°å¯¹åº”çš„çˆ¶å¯¹è±¡
        let foundParent = null;

        clonedRoot.traverse((clonedChild) => {
            if (foundParent) return;

            // é€šè¿‡nameåŒ¹é…æ¥æ‰¾åˆ°å¯¹åº”çš„å¯¹è±¡
            if (clonedChild.name === originalParent.name) {
                foundParent = clonedChild;
            }
        });

        return foundParent;
    }

    // åˆ‡æ¢ TransformControls çš„å¯ç”¨çŠ¶æ€
    toggleTransform() {
        if (!this.transformControls) return;
        this.transformEnabled = !this.transformEnabled;
        if (this.transformEnabled) {
            if (this.currentModel) {
                try {
                    this.transformControls.attach(this.currentModel);
                } catch (e) {
                    console.warn('attach transform failed', e);
                }
            }
            this.transformControls.visible = true;
        } else {
            try { this.transformControls.detach(); } catch (e) {}
            this.transformControls.visible = false;
        }
    }

    setTransformMode(mode) {
        if (!this.transformControls) return;
        if (['translate', 'rotate', 'scale'].includes(mode)) {
            this.transformControls.setMode(mode);
        }
    }

    setUniformScale(enabled) {
        this.uniformScale = !!enabled;
    }

    setUniformAlign(enabled) {
        this.uniformAlign = !!enabled;
        if (this.uniformAlign) {
            this._applyUniformAlignToAll();
        } else {
            // å¦‚æœå…³é—­ç»Ÿä¸€å¯¹é½ï¼Œä¸è‡ªåŠ¨è¿˜åŸåŸå§‹ä½ç½®ï¼ˆä¿æŒå½“å‰çŠ¶æ€ï¼‰
        }
    }

    // è®¾ç½®æ¨¡å‹ç»Ÿä¸€ç›®æ ‡å°ºå¯¸
    setModelTargetSize(size) {
        this.modelTargetSize = Number(size);
        console.log(`è®¾ç½®æ¨¡å‹ç›®æ ‡å°ºå¯¸ä¸º: ${this.modelTargetSize}`);
        // é‡æ–°åº”ç”¨å°ºå¯¸åˆ°æ‰€æœ‰å·²åŠ è½½çš„æ¨¡å‹
        this._applyModelTargetSizeToAll();
    }

    // åˆ‡æ¢æ¨¡å‹å¯è§æ€§
    toggleModelVisibility(id) {
        const entry = this.models.find(m => m.id === id);
        if (!entry) return;
        const prev = entry.visible;
        entry.visible = !entry.visible;
        if (entry.object) entry.object.visible = entry.visible;
        // æ›´æ–°æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤ºæ–‡æœ¬
        if (!this._suppressUndo) {
            this._pushUndo({ type: 'toggleVisibility', id, previous: prev });
        }
        const el = document.getElementById(`file-${id}`);
        if (el) {
            const status = el.querySelector('div div');
            if (status) status.textContent = entry.visible ? 'å¯è§' : 'éšè—';
            const hideBtn = el.querySelectorAll('button')[1];
            if (hideBtn) hideBtn.textContent = entry.visible ? 'éšè—' : 'æ˜¾ç¤º';
        }
        // å¦‚æœéšè—çš„æ˜¯å½“å‰æ¨¡å‹ï¼Œå–æ¶ˆé€‰ä¸­
        if (!entry.visible && this.currentModel === entry.object) {
            this.currentModel = null;
            this._updateSelectionHelper();
        }
    }

    // åˆ é™¤æ¨¡å‹
    removeModel(id) {
        const idx = this.models.findIndex(m => m.id === id);
        if (idx === -1) return;
        const entry = this.models[idx];
        // push undo info
        if (!this._suppressUndo) {
            this._pushUndo({ type: 'removeModel', id, object: entry.object, name: entry.name, index: idx });
        }
        if (entry.object) this.scene.remove(entry.object);
        if (this.currentModel === entry.object) {
            this.currentModel = null;
        }
        this.models.splice(idx, 1);
        // ç§»é™¤ UI
        const el = document.getElementById(`file-${id}`);
        if (el) el.remove();
        this._updateSelectionHelper();
    }

    // å†…éƒ¨ï¼šæ›´æ–°é€‰ä¸­æ¨¡å‹çš„è¾…åŠ©æ¡†
    _updateSelectionHelper() {
        // ç§»é™¤ä¹‹å‰çš„ box helper
        if (this.selectionBox) {
            this.scene.remove(this.selectionBox);
            this.selectionBox = null;
        }
        if (!this.currentModel) return;
        try {
            const box = new THREE.BoxHelper(this.currentModel, 0xffcc00);
            this.selectionBox = box;
            this.scene.add(box);
        } catch (e) {
            console.warn('åˆ›å»ºé€‰æ‹©æ¡†å¤±è´¥', e);
        }
    }

    // è°ƒæ•´ç›¸æœºä»¥é€‚é…æ‰€æœ‰å·²åŠ è½½æ¨¡å‹
    fitToAllModels() {
        if (!this.models || this.models.length === 0) return;
        const box = new THREE.Box3();
        let any = false;
        for (const m of this.models) {
            if (m.object && m.object.visible) {
                box.expandByObject(m.object);
                any = true;
            }
        }
        if (!any) return;
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const distance = (maxDim * 1.5) || 5;

        // å°†ç›¸æœºæ”¾åœ¨ä¸­å¿ƒçš„å¯¹è§’çº¿ä¸Š
        this.camera.position.copy(center);
        this.camera.position.x += distance;
        this.camera.position.y += distance * 0.5;
        this.camera.position.z += distance;
        this.camera.lookAt(center);
        if (this.controls) {
            this.controls.target.copy(center);
            this.controls.update();
        }
    }

    // è®¡ç®—ä¸‹ä¸€ä¸ªæ¨¡å‹æ”¾ç½®ä½ç½®ï¼ˆæŒ‰ç½‘æ ¼æ’åˆ—ï¼Œé¿å…é‡å ï¼‰
    _getNextModelPosition(index) {
        // ç½‘æ ¼åˆ—æ•°ä»¥ sqrt(å½“å‰æ•°ç›®+1) å‘ä¸Šå–æ•´
        const total = Math.max(1, this.models.length + 1);
        const cols = Math.ceil(Math.sqrt(total));
        const rows = Math.ceil(total / cols);

        const col = index % cols;
        const row = Math.floor(index / cols);

        // spacing åŸºäºç›®æ ‡æ¨¡å‹å°ºå¯¸
        const spacing = this.modelTargetSize * 2.5;
        const offsetX = (col - (cols - 1) / 2) * spacing;
        const offsetZ = (row - (rows - 1) / 2) * spacing;

        return new THREE.Vector3(offsetX, 0, offsetZ);
    }

    // å°†æ‰€æœ‰æ¨¡å‹ç»Ÿä¸€ç¼©æ”¾å¹¶æ”¾ç½®åˆ°ç›¸åŒä½ç½®
    _applyUniformAlignToAll() {
        if (!this.models || this.models.length === 0) return;
        const center = this.controls ? this.controls.target.clone() : new THREE.Vector3(0, 0, 0);
        const desiredXZ = new THREE.Vector3(center.x, 0, center.z);
        for (const m of this.models) {
            if (!m.object) continue;
            // è®¡ç®— bboxï¼Œå…ˆå°† bbox ä¸­å¿ƒç§»åˆ°åŸç‚¹ï¼Œå†ç¼©æ”¾ï¼Œç„¶åæŠŠ bbox.min.y å¯¹é½åˆ° 0 å¹¶å°† center.xz å¯¹é½åˆ° desiredXZ
            const box = new THREE.Box3().setFromObject(m.object);
            const objCenter = box.getCenter(new THREE.Vector3());
            m.object.position.sub(objCenter);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim > 0) {
                const scale = this.modelTargetSize / maxDim;
                m.object.scale.set(scale, scale, scale);
            }
            const boxAfter = new THREE.Box3().setFromObject(m.object);
            const centerAfter = boxAfter.getCenter(new THREE.Vector3());
            const minY = boxAfter.min.y;
            const translation = new THREE.Vector3(desiredXZ.x - centerAfter.x, -minY, desiredXZ.z - centerAfter.z);
            m.object.position.add(translation);
            m.visible = true;
            if (m.object) m.object.visible = true;
        }
        // é‡æ–°é€‰ä¸­å½“å‰æ¨¡å‹ä»¥æ›´æ–° selection box
        if (this.currentModel) this._updateSelectionHelper();
    }

    // å°†æ‰€æœ‰æ¨¡å‹é‡æ–°ç¼©æ”¾åˆ°å½“å‰ç›®æ ‡å°ºå¯¸
    _applyModelTargetSizeToAll() {
        if (!this.models || this.models.length === 0) return;

        for (const m of this.models) {
            if (!m.object) continue;

            // é‡ç½®æ¨¡å‹å˜æ¢ï¼ˆä½ç½®ã€æ—‹è½¬ã€ç¼©æ”¾ï¼‰
            m.object.position.set(0, 0, 0);
            m.object.rotation.set(0, 0, 0);
            m.object.scale.set(1, 1, 1);

            // è®¡ç®—åŸå§‹è¾¹ç•Œæ¡†
            const box = new THREE.Box3().setFromObject(m.object);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            // ç¼©æ”¾åˆ°ç›®æ ‡å¤§å°
            if (maxDim > 0) {
                const scale = this.modelTargetSize / maxDim;
                m.object.scale.set(scale, scale, scale);
            }

            // å¦‚æœå¯ç”¨äº†ç»Ÿä¸€å¯¹é½ï¼Œé‡æ–°åº”ç”¨å¯¹é½
            if (this.uniformAlign) {
                const center = this.controls ? this.controls.target.clone() : new THREE.Vector3(0, 0, 0);
                const desiredXZ = new THREE.Vector3(center.x, 0, center.z);

                // é‡æ–°è®¡ç®—ç¼©æ”¾åçš„è¾¹ç•Œæ¡†
                const boxAfter = new THREE.Box3().setFromObject(m.object);
                const centerAfter = boxAfter.getCenter(new THREE.Vector3());
                const minY = boxAfter.min.y;

                // ç§»åŠ¨åˆ°æŒ‡å®šä½ç½®
                const translation = new THREE.Vector3(desiredXZ.x - centerAfter.x, -minY, desiredXZ.z - centerAfter.z);
                m.object.position.add(translation);
            }
        }

        // é‡æ–°é€‰ä¸­å½“å‰æ¨¡å‹ä»¥æ›´æ–° selection box
        if (this.currentModel) this._updateSelectionHelper();

        // è°ƒæ•´ç›¸æœºé€‚åº”æ‰€æœ‰æ¨¡å‹
        this.fitToAllModels();
    }

    resetCamera() {
        this.camera.position.set(5, 5, 5);
        this.camera.lookAt(0, 0, 0);
        this.controls.target.set(0, 0, 0);
        this.controls.update();
    }

    showWireframe() {
        if (!this.currentModel) return;

        this.currentModel.traverse((child) => {
            if (child.isMesh && child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(mat => {
                        mat.wireframe = true;
                    });
                } else {
                    child.material.wireframe = true;
                }
            }
        });
    }

    showSolid() {
        if (!this.currentModel) return;

        this.currentModel.traverse((child) => {
            if (child.isMesh && child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(mat => {
                        mat.wireframe = false;
                    });
                } else {
                    child.material.wireframe = false;
                }
            }
        });
    }

    setBackground(type) {
        const container = document.getElementById('viewer');
        if (type === 'white') {
            this.scene.background = new THREE.Color(0xffffff);
            if (container) container.style.background = '';
            this._updateBgColorDisplay('#FFFFFF');
        } else if (type === 'black') {
            this.scene.background = new THREE.Color(0x000000);
            if (container) container.style.background = '';
            this._updateBgColorDisplay('#000000');
        } else if (type === 'gradient') {
            // è®© scene ä½¿ç”¨é€æ˜èƒŒæ™¯ï¼Œæ˜¾ç¤ºå®¹å™¨ CSS æ¸å˜
            this.scene.background = null;
            if (container) container.style.background = 'linear-gradient(180deg, #000000 0%, #444444 100%)';
            this._updateBgColorDisplay('æ¸å˜');
        } else if (type.startsWith('#')) {
            // è‡ªå®šä¹‰é¢œè‰²
            try {
                this.scene.background = new THREE.Color(type);
                if (container) container.style.background = '';
                this._updateBgColorDisplay(type.toUpperCase());
            } catch (e) {
                console.warn('æ— æ•ˆçš„èƒŒæ™¯é¢œè‰²:', type);
                // å¦‚æœé¢œè‰²æ— æ•ˆï¼Œæ¢å¤ä¸ºç™½è‰²èƒŒæ™¯
                this.scene.background = new THREE.Color(0xffffff);
                if (container) container.style.background = '';
                this._updateBgColorDisplay('#FFFFFF');
            }
        }
    }

    _updateBgColorDisplay(value) {
        const valueDisplay = document.getElementById('bgColorValue');
        if (valueDisplay) valueDisplay.textContent = value;
        const picker = document.getElementById('bgColorPicker');
        if (picker && value.startsWith('#')) {
            picker.value = value.toLowerCase();
        }
    }

    // å›¾ç‰‡åŠŸèƒ½å·²ç§»é™¤ï¼ˆæŒ‰ç”¨æˆ·è¦æ±‚ï¼‰

    onWindowResize() {
        const container = document.getElementById('viewer');
        const width = container.clientWidth;
        const height = container.clientHeight;

        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
        // æ›´æ–°å››è§†å›¾ç›¸æœºæ¯”ä¾‹
        // no quad cameras
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        const container = document.getElementById('viewer');
        const width = container.clientWidth;
        const height = container.clientHeight;

        this.renderer.setViewport(0, 0, width, height);
        this.renderer.render(this.scene, this.camera);

        // æ¸²æŸ“è¾…åŠ©è§†å›¾ï¼ˆå¦‚æœå¯è§ï¼‰
        if (this.auxViewVisible && this.auxRenderer && this.auxCamera) {
            this.auxRenderer.render(this.scene, this.auxCamera);
        }

        // åŒæ­¥æ‘„åƒæœº UIï¼ˆä½ç½®/è§’åº¦/ç„¦è·æ˜¾ç¤ºï¼‰
        try {
            this._updateCameraUI();
        } catch (e) {
            // ignore UI update errors
        }
    }

    showLoading() {
        const loading = document.createElement('div');
        loading.className = 'loading';
        loading.id = 'loading';
        loading.innerHTML = `
            <div class="spinner"></div>
            <p>æ­£åœ¨åŠ è½½æ¨¡å‹...</p>
        `;
        document.getElementById('viewer').appendChild(loading);
    }

    hideLoading() {
        const loading = document.getElementById('loading');
        if (loading) {
            loading.remove();
        }
    }

    showMessage(message, type) {
        // ç§»é™¤ä¹‹å‰çš„æ¶ˆæ¯
        const existingMessage = document.querySelector('.error-message, .success-message');
        if (existingMessage) {
            existingMessage.remove();
        }

        const messageDiv = document.createElement('div');
        messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
        messageDiv.textContent = message;

        document.querySelector('.viewer-container').appendChild(messageDiv);

        // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.remove();
            }
        }, 3000);
    }

    // ç¯å…‰æ§åˆ¶æ–¹æ³•
    setAmbientIntensity(value) {
        const val = Number(value);
        // åªæ§åˆ¶ç¯å¢ƒå…‰å¼ºåº¦ï¼ˆå…¨å±€åŸºç¡€å…‰ï¼‰
        if (this.ambientLight) {
            this.ambientLight.intensity = val;
        } else {
            console.warn('ç¯å¢ƒå…‰æœªåˆå§‹åŒ–ï¼Œæ— æ³•è®¾ç½®å¼ºåº¦');
        }
        // åŒæ­¥ hemisphere lightï¼ˆå¦‚æœå­˜åœ¨ï¼‰ï¼Œç¡®ä¿åœ¨æ²¡æœ‰æ–¹å‘å…‰æ—¶ä¹Ÿèƒ½ç…§äº®åœºæ™¯
        if (this.hemiLight) {
            this.hemiLight.intensity = val * 0.8;
        }

        // å¯¹äºæ‰€æœ‰æè´¨ç±»å‹ï¼Œè°ƒæ•´ç¯å¢ƒå…‰å½±å“
        this.models.forEach(model => {
            if (model.object) {
                model.object.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(mat => {
                            // å¯¹äº PBR æè´¨ï¼Œè®¾ç½® envMapIntensity æ¥æ§åˆ¶ç¯å¢ƒå…‰å½±å“
                            if (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial) {
                                // ç¡®ä¿ envMapIntensity å§‹ç»ˆè¢«è®¾ç½®ï¼Œä»¥ä¾¿ PBR æè´¨èƒ½å“åº”ç¯å¢ƒå…‰å˜åŒ–
                                try {
                                    // ç›´æ¥å†™å…¥ envMapIntensityï¼ˆå³ä¾¿ä¹‹å‰æœªå®šä¹‰ï¼‰
                                    mat.envMapIntensity = Math.max(0.0, val * 0.5);
                                    // å¦‚æœæè´¨æ²¡æœ‰ envMapï¼Œä½†æˆ‘ä»¬ä»ç„¶å¸Œæœ›åœºæ™¯çœ‹èµ·æ¥æ›´äº®ï¼Œå¯é€šè¿‡è°ƒæ•´ renderer exposure è¾…åŠ©
                                } catch (e) {
                                    // ignore
                                }

                                // åŒæ—¶è°ƒæ•´æè´¨çš„ç¯å¢ƒå…‰é¢œè‰²å½±å“ï¼ˆä¿å®ˆå¤„ç†ï¼‰
                                if (mat.aoMapIntensity !== undefined) {
                                    mat.aoMapIntensity = Math.min(mat.aoMapIntensity || 1, 1);
                                }
                            }
                            // å¯¹äºä¼ ç»Ÿæè´¨ï¼ˆLambert, Phongç­‰ï¼‰ï¼Œå¦‚æœå®ƒä»¬æ²¡æœ‰å“åº”ç¯å¢ƒå…‰ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è°ƒæ•´emissive
                            else if (mat.isMeshLambertMaterial || mat.isMeshPhongMaterial) {
                            // ä¸é€šè¿‡ä¿®æ”¹ emissive åšè‡ªåŠ¨è¡¥å¿ï¼Œä»¥é¿å…æœªé€‰ä¸­æ¨¡å‹å‡ºç°é«˜äº®
                            }

                            // å¼ºåˆ¶æ›´æ–°æè´¨
                            mat.needsUpdate = true;
                        });
                    }
                });
            }
        });

        // å¼ºåˆ¶é‡æ–°æ¸²æŸ“åœºæ™¯
        if (this.renderer) {
            // å…¼é¡¾ PBR æ¸²æŸ“æ¨¡å‹ï¼ˆGLBï¼‰ï¼Œé€šè¿‡æ›å…‰è¾…åŠ©æ”¾å¤§ç¯å¢ƒå…‰å½±å“
            try {
                // exposure æ˜ å°„ï¼šval (0-2) -> exposure (0.6 - 2.0)
                const exposure = Math.min(2.0, Math.max(0.2, 0.6 + val * 0.7));
                if (this.renderer.toneMappingExposure !== undefined) {
                    this.renderer.toneMappingExposure = exposure;
                }
            } catch (e) { /* ignore */ }
            this.renderer.render(this.scene, this.camera);
        }
    }

    setDirectionalIntensity(value) {
        const val = Number(value);
        if (this.directionalLight) this.directionalLight.intensity = val;
    }

    setDirectionalPosition(x, y, z) {
        if (!this.directionalLight) return;
        const px = (x !== null && x !== undefined) ? Number(x) : this.directionalLight.position.x;
        const py = (y !== null && y !== undefined) ? Number(y) : this.directionalLight.position.y;
        const pz = (z !== null && z !== undefined) ? Number(z) : this.directionalLight.position.z;
        this.directionalLight.position.set(px, py, pz);
        // ç¡®ä¿ç›®æ ‡æ›´æ–°ï¼ˆæŒ‡å‘åŸç‚¹ï¼‰
        if (this.directionalLight.target) {
            this.directionalLight.target.position.set(0, 0, 0);
            this.directionalLight.target.updateMatrixWorld();
        }
    }

    setDirectionalColor(hex) {
        if (!this.directionalLight) return;
        try {
            this.directionalLight.color.set(hex);
        } catch (e) {
            console.warn('è®¾ç½®æ–¹å‘å…‰é¢œè‰²å¤±è´¥:', e);
        }
    }

    // æ‘„åƒæœºæ§åˆ¶ç›¸å…³
    setCameraFov(deg) {
        if (!this.camera) return;
        const f = Number(deg);
        if (isNaN(f)) return;
        this.camera.fov = f;
        try { this.camera.updateProjectionMatrix(); } catch (e) {}
    }

    // è®¾ç½®ç„¦è·ï¼ˆ35mm ç­‰æ•ˆ, mmï¼‰ï¼Œä¼šæ¢ç®—ä¸º FOV å¹¶æ›´æ–°æ‘„åƒæœº
    setCameraFocalLengthMm(mm) {
        if (!this.camera) return;
        const fmm = Number(mm);
        if (isNaN(fmm) || fmm <= 0) return;
        const sensorHeight = this._sensorHeightMm || 24.0;
        // fov (vertical) = 2 * atan( sensorHeight / (2 * focalLength) )
        const vFovRad = 2 * Math.atan((sensorHeight / 2) / fmm);
        const vFovDeg = THREE.Math.radToDeg(vFovRad);
        this.camera.fov = vFovDeg;
        try { this.camera.updateProjectionMatrix(); } catch (e) {}
    }

    _updateCameraUI() {
        const fovEl = document.getElementById('camFovVal');
        const slider = document.getElementById('camFovSlider');
        const focalEl = document.getElementById('camFocalInput');
        const posX = document.getElementById('camPosX');
        const posY = document.getElementById('camPosY');
        const posZ = document.getElementById('camPosZ');
        const rotX = document.getElementById('camRotX');
        const rotY = document.getElementById('camRotY');
        const rotZ = document.getElementById('camRotZ');

        if (this.camera) {
            const fov = this.camera.fov;
            if (fovEl) fovEl.textContent = fov.toFixed(2);
            if (slider && Math.abs(Number(slider.value) - fov) > 0.01) slider.value = fov;
            // è®¡ç®— 35mm ç­‰æ•ˆç„¦è·ï¼ˆåŸºäº sensorHeightï¼‰
            const sensorHeight = this._sensorHeightMm || 24.0;
            const fmm = (sensorHeight / 2) / Math.tan(THREE.Math.degToRad(fov) / 2);
            if (focalEl && Math.abs(Number(focalEl.value) - fmm) > 0.01) focalEl.value = fmm.toFixed(2);

            // compute view info relative to controls.target
            try {
                const vd = this.computeViewDirectionLabel();
                // Compose summary string like:
                // Location: X:-4.00, Y:3.50, Z:4.00; Horizontal angle: 315.00Â°; Vertical angle: 27.14Â°; FOV: 75.0
                const camPos = this.camera.position;
                const fovVal = this.camera.fov !== undefined ? this.camera.fov.toFixed(1) : 'N/A';
                const summary = `Location: X:${camPos.x.toFixed(2)}, Y:${camPos.y.toFixed(2)}, Z:${camPos.z.toFixed(2)}; Horizontal angle: ${vd.yawDeg.toFixed(2)}Â°; Vertical angle: ${vd.elevDeg.toFixed(2)}Â°; FOV: ${fovVal}`;
                const summaryEl = document.getElementById('camSummary');
                if (summaryEl) summaryEl.textContent = summary;
                const bottomSummaryEl = document.getElementById('bottomCamSummary');
                if (bottomSummaryEl) bottomSummaryEl.textContent = summary;

                // è®¡ç®—å¹¶æ˜¾ç¤ºè§†å›¾æ–¹å‘æ ‡ç­¾ (English)
                const el = document.getElementById('viewDirection');
                if (el) el.textContent = vd.label;
                const bottomViewEl = document.getElementById('bottomViewDirection');
                if (bottomViewEl) bottomViewEl.textContent = vd.label;
                // æ˜¾ç¤º shot scale (English)
                try {
                    const shot = this.computeShotScale(vd.distance);
                    const shotEl = document.getElementById('shotScale');
                    if (shotEl) shotEl.textContent = shot;
                    const bottomShotEl = document.getElementById('bottomShotScale');
                    if (bottomShotEl) bottomShotEl.textContent = shot;
                } catch (e) {}
            } catch (e) {
                // ignore
            }
        }
    }

    // æ ¹æ®ç›¸æœºä½ç½®å’Œç›®æ ‡ä¸­å¿ƒè®¡ç®—è§†è§’æ–¹å‘æ ‡ç­¾
    computeViewDirectionLabel() {
        // ä½¿ç”¨ controls.target ä½œä¸ºæ¨¡å‹ä¸­å¿ƒï¼ˆå¦‚æœæ²¡æœ‰æ¨¡å‹åˆ™ä½¿ç”¨åŸç‚¹ï¼‰
        const center = (this.controls && this.controls.target) ? this.controls.target.clone() : new THREE.Vector3(0, 0, 0);
        const camPos = this.camera.position.clone();
        const v = camPos.sub(center);
        const x = v.x, y = v.y, z = v.z;

        // è®¡ç®—æ°´å¹³è§’åº¦ï¼ˆä»¥æ­£å‰æ–¹ (z positive) ä¸º 0ï¼Œé¡ºæ—¶é’ˆä¸ºæ­£ï¼Œå•ä½åº¦ï¼‰
        const yawRad = Math.atan2(x, z); // x first so 0 at +z
        let yawDeg = THREE.Math.radToDeg(yawRad);
        // è§„èŒƒåˆ° [-180,180]
        if (yawDeg > 180) yawDeg -= 360;
        if (yawDeg <= -180) yawDeg += 360;

        // è®¡ç®—ä»°ä¿¯è§’ï¼ˆä»¥æ°´å¹³é¢ä¸º 0ï¼Œå‘ä¸Šä¸ºæ­£ï¼‰
        const horizDist = Math.sqrt(x * x + z * z);
        const elevRad = Math.atan2(y, horizDist);
        const elevDeg = THREE.Math.radToDeg(elevRad);

        // åˆ¤æ–­æç«¯å‚ç›´ï¼ˆtop-down / bottom-upï¼‰
        const TOP_DOWN_THRESHOLD = 70; // deg
        const UPPER_THRESHOLD = 15;
        const LOWER_THRESHOLD = -15;

        // æ°´å¹³æ–¹å‘åˆ†åŒºï¼šæ¯45åº¦ä¸ºä¸€ä¸ªæ‰‡åŒºä¸­å¿ƒï¼ˆfront=0, front-right=45, right=90...ï¼‰
        // å°† yawDeg æ˜ å°„åˆ°æœ€è¿‘çš„ 45 åº¦å€æ•°çš„ç´¢å¼• 0..7
        let sectorIndex = Math.round(yawDeg / 45);
        // Normalize to -4..4
        if (sectorIndex > 4) sectorIndex -= 8;
        // Map indices to English base names
        const sectorMapEn = {
            0: 'front',
            1: 'front-right',
            2: 'right',
            3: 'back-right',
            4: 'back',
            '-3': 'back-left',
            '-2': 'left',
            '-1': 'front-left'
        };
        const baseEn = sectorMapEn[sectorIndex] || 'front';

        // Decide final English label
        let label = '';
        if (elevDeg >= TOP_DOWN_THRESHOLD) {
            label = `top-down-${baseEn}`;
        } else if (elevDeg <= -TOP_DOWN_THRESHOLD) {
            label = `bottom-up-${baseEn}`;
        } else if (elevDeg > UPPER_THRESHOLD) {
            label = `${baseEn}-upper`;
        } else if (elevDeg < LOWER_THRESHOLD) {
            label = `${baseEn}-lower`;
        } else {
            label = baseEn;
        }

        // normalize yaw to 0..360
        let yawNorm = yawDeg;
        if (yawNorm < 0) yawNorm += 360;
        // vertical angle expressed as positive degrees
        const elevAbs = Math.abs(elevDeg);

        return {
            label,
            yawDeg: yawNorm,
            elevDeg: elevAbs,
            distance: Math.sqrt(x * x + y * y + z * z)
        };
    }

    // æ ¹æ®è·ç¦»è¿”å›ä¸­æ–‡æ™¯åˆ«
    computeShotScale(distance) {
        // ä½¿ç”¨ modelTargetSize ä½œä¸ºå‚è€ƒå•ä½ï¼ˆæ¨¡å‹å·²ç»Ÿä¸€ç¼©æ”¾ï¼‰
        const unit = Math.max(0.0001, this.modelTargetSize || 1.0);
        const d = Number(distance);
        // é˜ˆå€¼ä»¥ unit ä¸ºåŸºå‡†ï¼Œè°ƒæ•´ä¸ºå¸¸è§æ‘„å½±è·ç¦»æ„Ÿå—
        // English shot scales: Close-up, Near shot, Medium close-up, Medium shot, Wide shot, Long shot
        if (d <= 0.8 * unit) return 'Close-up';
        if (d <= 1.6 * unit) return 'Near shot';
        if (d <= 3.0 * unit) return 'Medium close-up';
        if (d <= 6.0 * unit) return 'Medium shot';
        if (d <= 12.0 * unit) return 'Wide shot';
        return 'Long shot';
    }

    // æˆªå±æ¡†æ§åˆ¶
    setCaptureFrameVisible(visible) {
        this.captureFrameVisible = !!visible;
        if (this.captureFrameEl) this.captureFrameEl.style.display = this.captureFrameVisible ? 'block' : 'none';
    }

    setCaptureFrameSize(wPct, hPct) {
        const w = Number(wPct);
        const h = Number(hPct);
        if (isNaN(w) || isNaN(h)) return;
        this.captureFrameSize = Object.assign(this.captureFrameSize || {}, { mode: 'pct', wPct: w, hPct: h });
        if (this.captureFrameEl) {
            this.captureFrameEl.style.width = `${w}%`;
            this.captureFrameEl.style.height = `${h}%`;
        }
    }

    exportCaptureImage() {
        if (!this.captureFrameEl || !this.renderer || !this.renderer.domElement) {
            console.warn('æ²¡æœ‰å¯ç”¨çš„æˆªå±æ¡†æˆ–æ¸²æŸ“å™¨');
            return;
        }
        const canvas = this.renderer.domElement;
        const canvasRect = canvas.getBoundingClientRect();
        const overlayRect = this.captureFrameEl.getBoundingClientRect();

        // è®¡ç®—æ¯”ä¾‹ï¼ˆcanvas å®é™…åƒç´  / CSS æ˜¾ç¤ºåƒç´ ï¼‰
        const scaleX = canvas.width / canvasRect.width;
        const scaleY = canvas.height / canvasRect.height;

        const sx = Math.max(0, Math.round((overlayRect.left - canvasRect.left) * scaleX));
        const sy = Math.max(0, Math.round((overlayRect.top - canvasRect.top) * scaleY));
        const sWidth = Math.max(1, Math.round(overlayRect.width * scaleX));
        const sHeight = Math.max(1, Math.round(overlayRect.height * scaleY));

        // åˆ›å»ºä¸´æ—¶ç”»å¸ƒå¹¶ç»˜åˆ¶è£å‰ªåŒºåŸŸï¼ˆå¯é€‰åŒ…å«èƒŒæ™¯ï¼‰
        const tmp = document.createElement('canvas');
        tmp.width = sWidth;
        tmp.height = sHeight;
        try {
            const ctx = tmp.getContext('2d', { alpha: false });
            // å¦‚æœéœ€è¦åŒ…å«èƒŒæ™¯ï¼Œå…ˆå¡«å……èƒŒæ™¯è‰²
            if (this.captureIncludeBackground) {
                let bg = null;
                try {
                    if (this.scene && this.scene.background && this.scene.background.isColor) {
                        bg = `#${this.scene.background.getHexString()}`;
                    }
                } catch (e) {}
                if (!bg) {
                    try {
                        const container = document.getElementById('viewer');
                        const cs = window.getComputedStyle(container);
                        bg = cs.backgroundColor || '#ffffff';
                    } catch (e) {
                        bg = '#ffffff';
                    }
                }
                ctx.fillStyle = bg;
                ctx.fillRect(0, 0, sWidth, sHeight);
            } else {
                // æ¸…ç©ºç”»å¸ƒä¸ºé€æ˜
                ctx.clearRect(0, 0, sWidth, sHeight);
            }
            ctx.drawImage(canvas, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
            const dataUrl = tmp.toDataURL('image/png');
            // å¦‚æœ URL hash æŒ‡ç¤ºè‡ªåŠ¨ä¸Šä¼ ï¼ˆ#capture:tokenï¼‰ï¼Œåˆ™ POST åˆ°æœ¬åœ°æœåŠ¡å™¨çš„ upload æ¥å£
            try {
                const h = location.hash || '';
                if (h && h.startsWith('#capture:')) {
                    const token = h.substring(9);
                    const uploadUrl = `/upload_screenshot?token=${encodeURIComponent(token)}`;
                    // ä»¥ JSON å½¢å¼ POST { dataUrl: 'data:image/png;base64,...' }
                    fetch(uploadUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ dataUrl })
                    }).catch(() => {});
                    // ä¸è§¦å‘æµè§ˆå™¨ä¸‹è½½ï¼ˆç”±æ¥æ”¶ç«¯ä¿å­˜ï¼‰
                } else {
                    // è§¦å‘ä¸‹è½½ï¼ˆæ­£å¸¸ UI è¡Œä¸ºï¼‰
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = 'screenshot.png';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                }
            } catch (e) {
                // å›é€€åˆ°ä¸‹è½½
                try {
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = 'screenshot.png';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                } catch (e) {}
            }
        } catch (e) {
            console.error('å¯¼å‡ºæˆªå±å¤±è´¥', e);
        }
    }

    setCaptureFrameSizePx(wPx, hPx) {
        const w = Number(wPx);
        const h = Number(hPx);
        if (isNaN(w) || isNaN(h)) return;
        this.captureFrameSize = Object.assign(this.captureFrameSize || {}, { mode: 'px', wPx: w, hPx: h });
        if (this.captureFrameEl) {
            this.captureFrameEl.style.width = `${w}px`;
            this.captureFrameEl.style.height = `${h}px`;
        }
    }

    setCaptureIncludeBackground(enabled) {
        this.captureIncludeBackground = !!enabled;
    }

    resetLighting() {
        if (this.ambientLight) this.ambientLight.intensity = 0.6;
        if (this.directionalLight) {
            this.directionalLight.intensity = 0.8;
            this.directionalLight.position.set(10, 10, 5);
            this.directionalLight.color.set(0xffffff);
        }
        // ä¿æŒæ¸²æŸ“å™¨æ›å…‰ä¸è¢«ç¯å¢ƒå…‰è‡ªåŠ¨ä¿®æ”¹ï¼ˆç¯å¢ƒå…‰ä»…å½±å“ ambientLightï¼‰
        // æ›´æ–°UIæ˜¾ç¤ºå€¼ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        const amb = document.getElementById('ambientVal');
        if (amb) amb.textContent = (this.ambientLight ? this.ambientLight.intensity : 0).toFixed(2);
        const dir = document.getElementById('dirVal');
        if (dir) dir.textContent = (this.directionalLight ? this.directionalLight.intensity : 0).toFixed(2);
        const dirX = document.getElementById('dirX');
        const dirY = document.getElementById('dirY');
        const dirZ = document.getElementById('dirZ');
        if (dirX && dirY && dirZ && this.directionalLight) {
            dirX.value = this.directionalLight.position.x;
            dirY.value = this.directionalLight.position.y;
            dirZ.value = this.directionalLight.position.z;
        }
    }

    // æ·»åŠ é€šç”¨ç¯å…‰ç®¡ç†å‡½æ•°
    addLight(type = 'directional') {
        // è®¡ç®—æ”¾ç½®åœ¨è§†å›¾ä¸­å¿ƒé™„è¿‘çš„ä½ç½®ï¼ˆä½äºç›¸æœºå‰æ–¹ï¼Œæœå‘ controls.targetï¼‰
        const center = this.controls ? this.controls.target.clone() : new THREE.Vector3(0, 0, 0);
        const camDir = new THREE.Vector3();
        this.camera.getWorldDirection(camDir);
        const camPos = this.camera.position.clone();
        const distance = camPos.distanceTo(center) * 0.5 || 5;
        const pos = center.clone().add(camDir.clone().negate().multiplyScalar(distance));

        const id = `light-${this.lightIdCounter++}`;
        if (type === 'directional') {
            const l = new THREE.DirectionalLight(0xffffff, 1.0);
            l.position.copy(pos);
            l.castShadow = true;
            this.scene.add(l);
            this.scene.add(l.target);

            // helper sphere
            const geom = new THREE.SphereGeometry(0.12, 12, 12);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffee88 });
            const helper = new THREE.Mesh(geom, mat);
            helper.position.copy(pos);
            helper.name = `helper-${id}`;
            this.scene.add(helper);

            this.userLights[id] = { id, light: l, helper, type: 'directional' };
            // create UI
            if (typeof createLightUI === 'function') createLightUI(id, 'æ–¹å‘å…‰', l.intensity, '#ffffff');
        } else if (type === 'point') {
            const l = new THREE.PointLight(0xffffff, 1.0, 0, 2);
            l.position.copy(pos);
            l.castShadow = true;
            this.scene.add(l);

            const geom = new THREE.SphereGeometry(0.1, 10, 10);
            const mat = new THREE.MeshBasicMaterial({ color: 0x88ccff });
            const helper = new THREE.Mesh(geom, mat);
            helper.position.copy(pos);
            helper.name = `helper-${id}`;
            this.scene.add(helper);

            this.userLights[id] = { id, light: l, helper, type: 'point' };
            if (typeof createLightUI === 'function') createLightUI(id, 'ç‚¹å…‰', l.intensity, '#ffffff');
        }
    }

    // å…¨å±€æ˜¾ç¤º/éšè— helper
    setHelpersVisible(visible) {
        this.helpersVisible = !!visible;
        // é»˜è®¤æ–¹å‘å…‰ helper
        if (this.lightHelper) this.lightHelper.visible = this.helpersVisible;
        // ç”¨æˆ·ç¯å…‰ helper
        for (const id in this.userLights) {
            const entry = this.userLights[id];
            if (entry && entry.helper) entry.helper.visible = this.helpersVisible;
        }
    }

    // æ˜¾ç¤º/éšè—åœ°é¢ç½‘æ ¼
    setGridVisible(visible) {
        if (!this.gridHelper) return;
        this.gridHelper.visible = !!visible;
    }

    // å››è§†å›¾åŠŸèƒ½å·²ç§»é™¤

    setLightIntensity(id, value) {
        const entry = this.userLights[id];
        if (!entry || !entry.light) return;
        entry.light.intensity = Number(value);
    }

    setLightColor(id, hex) {
        const entry = this.userLights[id];
        if (!entry || !entry.light) return;
        try {
            entry.light.color.set(hex);
            if (entry.helper && entry.helper.material) entry.helper.material.color.set(hex);
        } catch (e) {
            console.warn('è®¾ç½®ç¯å…‰é¢œè‰²å¤±è´¥', e);
        }
    }

    removeLight(id) {
        const entry = this.userLights[id];
        if (!entry) return;
        if (entry.helper) {
            this.scene.remove(entry.helper);
        }
        if (entry.light) {
            this.scene.remove(entry.light);
            if (entry.type === 'directional' && entry.light.target) {
                this.scene.remove(entry.light.target);
            }
        }
        delete this.userLights[id];
    }

    // è¾…åŠ©è§†å›¾ç›¸å…³æ–¹æ³•
    captureCurrentView() {
        if (!this.auxCamera) {
            console.warn('è¾…åŠ©è§†å›¾æœªåˆå§‹åŒ–');
            return;
        }

        // å¤åˆ¶å½“å‰ä¸»ç›¸æœºçš„ä½ç½®å’Œè§’åº¦åˆ°è¾…åŠ©ç›¸æœº
        this.auxCamera.position.copy(this.camera.position);
        this.auxCamera.quaternion.copy(this.camera.quaternion);
        this.auxCamera.fov = this.camera.fov;
        this.auxCamera.updateProjectionMatrix();

        // æ˜¾ç¤ºè¾…åŠ©è§†å›¾
        this.showAuxView();

        console.log('å·²å›ºå®šå½“å‰è§†è§’åˆ°è¾…åŠ©è§†å›¾');
    }

    showAuxView() {
        const auxContainer = document.getElementById('auxViewContainer');
        if (auxContainer) {
            auxContainer.style.display = 'block';
            this.auxViewVisible = true;
        }
    }

    hideAuxView() {
        const auxContainer = document.getElementById('auxViewContainer');
        if (auxContainer) {
            auxContainer.style.display = 'none';
            this.auxViewVisible = false;
        }

        // æ¸…ç†resizeç›‘å¬å™¨
        if (this.auxViewResizeObserver) {
            this.auxViewResizeObserver.disconnect();
            this.auxViewResizeObserver = null;
        }
        if (this.auxViewResizeInterval) {
            clearInterval(this.auxViewResizeInterval);
            this.auxViewResizeInterval = null;
        }
    }

}

// å…¨å±€å‡½æ•°ä¾›HTMLè°ƒç”¨
let viewer;

function resetCamera() {
    if (viewer) viewer.resetCamera();
}

function captureCurrentView() {
    if (viewer) viewer.captureCurrentView();
}

function hideAuxView() {
    if (viewer) viewer.hideAuxView();
}

function authorizeOverwrite() {
    if (!viewer) {
        alert('æŸ¥çœ‹å™¨æœªåˆå§‹åŒ–ï¼Œæ— æ³•æˆæƒè¦†ç›–ä¿å­˜');
        return;
    }
    // è¯·æ±‚å¹¶æŒä¹…åŒ–å¥æŸ„ä»¥æ”¯æŒè¦†ç›–ä¿å­˜ï¼ˆä»… Chromium æ”¯æŒï¼‰
    if (typeof viewer.requestAndPersistHandle === 'function') {
        viewer.requestAndPersistHandle(viewer.currentProjectFileName).then((handle) => {
            if (handle) {
                alert('å·²æˆæƒè¦†ç›–ä¿å­˜ã€‚æ­¤åç‚¹å‡»ä¿å­˜å°†ç›´æ¥è¦†ç›–è¯¥å·¥ç¨‹æ–‡ä»¶ï¼ˆå–å†³äºæµè§ˆå™¨æƒé™ï¼‰ã€‚');
                try { updateProjectStatus(); } catch (e) {}
            } else {
                alert('æœªè·å–åˆ°æ–‡ä»¶å¥æŸ„æˆ–æœªæˆäºˆå†™æƒé™ã€‚');
            }
        }).catch((e) => {
            console.warn('æˆæƒè¦†ç›–ä¿å­˜å¤±è´¥', e);
            alert('æˆæƒè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ' + (e && e.message ? e.message : e));
        });
    } else {
        alert('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒè¦†ç›–ä¿å­˜çš„æˆäºˆæµç¨‹ï¼Œè¯·ä½¿ç”¨æ”¯æŒ File System Access API çš„æµè§ˆå™¨ï¼ˆChromium å†…æ ¸ï¼‰ã€‚');
    }
}

function fitToView() {
    if (!viewer) return;
    try {
        // ä¼˜å…ˆé’ˆå¯¹å½“å‰é€‰ä¸­æ¨¡å‹é€‚é…è§†å›¾ï¼Œå¦åˆ™å›é€€åˆ°é€‚é…æ‰€æœ‰æ¨¡å‹
        if (viewer.currentModel) {
            viewer.fitToView();
        } else {
            // å¦‚æœæ²¡æœ‰é€‰ä¸­æ¨¡å‹ï¼Œé€‚é…æ‰€æœ‰å·²åŠ è½½çš„æ¨¡å‹
            if (typeof viewer.fitToAllModels === 'function') {
                viewer.fitToAllModels();
            } else {
                viewer.fitToView();
            }
        }
    } catch (e) {
        console.warn('fitToView å›é€€æ‰§è¡Œå¤±è´¥ï¼Œå°è¯•ç›´æ¥è°ƒç”¨ viewer.fitToView()', e);
        try { viewer.fitToView(); } catch (e2) { /* ignore */ }
    }
}

function showWireframe() {
    if (viewer) viewer.showWireframe();
}

function showSolid() {
    if (viewer) viewer.showSolid();
}

function setBackground(type) {
    if (viewer) viewer.setBackground(type);
}

function setCustomBackground(color) {
    if (viewer) {
        viewer.setBackground(color);
        // æ›´æ–°é¢œè‰²é€‰æ‹©å™¨çš„å€¼
        const picker = document.getElementById('bgColorPicker');
        if (picker) picker.value = color.toLowerCase();
        // æ›´æ–°æ˜¾ç¤ºçš„é¢œè‰²å€¼
        const valueDisplay = document.getElementById('bgColorValue');
        if (valueDisplay) valueDisplay.textContent = color.toUpperCase();
    }
}

// å›¾ç‰‡ä¸Šä¼ å¤„ç†
// å›¾ç‰‡åŠŸèƒ½å·²ä»UIç§»é™¤

// ç¯å…‰UIå›è°ƒ
function updateAmbientIntensity(value) {
    const v = Number(value);
    const el = document.getElementById('ambientVal');
    if (el) el.textContent = v.toFixed(2);
    if (viewer) viewer.setAmbientIntensity(v);
}

function updateDirectionalIntensity(value) {
    const v = Number(value);
    const el = document.getElementById('dirVal');
    if (el) el.textContent = v.toFixed(2);
    if (viewer) viewer.setDirectionalIntensity(v);
}

function updateDirectionalPos(x, y, z) {
    // æ”¯æŒå•é¡¹æ›´æ–°ï¼šå¦‚æœå‚æ•°ä¸ºnullåˆ™ä¿æŒåŸå€¼
    const xEl = document.getElementById('dirX');
    const yEl = document.getElementById('dirY');
    const zEl = document.getElementById('dirZ');
    let px = xEl ? Number(xEl.value) : null;
    let py = yEl ? Number(yEl.value) : null;
    let pz = zEl ? Number(zEl.value) : null;
    if (x !== null && x !== undefined) px = Number(x);
    if (y !== null && y !== undefined) py = Number(y);
    if (z !== null && z !== undefined) pz = Number(z);
    if (viewer) viewer.setDirectionalPosition(px, py, pz);
}

function updateDirectionalColor(hex) {
    if (viewer) viewer.setDirectionalColor(hex);
}

function resetLighting() {
    if (viewer) viewer.resetLighting();
}


function addDirectionalLight() {
    if (viewer) viewer.addLight('directional');
}

function addPointLight() {
    if (viewer) viewer.addLight('point');
}

function applyEnvColor() {
    const colorEl = document.getElementById('envColorPicker');
    const intensityEl = document.getElementById('envColorIntensity');
    const color = colorEl ? colorEl.value : '#ffffff';
    const intensity = intensityEl ? Number(intensityEl.value) : 1.0;
    if (!viewer) return;
    // å¦‚æœå·²ç»åŠ è½½äº† HDRI/ç¯å¢ƒè´´å›¾ï¼Œè‡ªå®šä¹‰é¢œè‰²ä¸åº”è¯¥ç”Ÿæ•ˆ
    if (viewer._currentEnvMap) {
        viewer.showMessage('å·²åŠ è½½ç¯å¢ƒè´´å›¾ (HDRI)ã€‚è¯·å…ˆæ¸…é™¤ç¯å¢ƒè´´å›¾åå†åº”ç”¨è‡ªå®šä¹‰ç¯å¢ƒè‰²ã€‚', 'warning');
        return;
    }
    viewer.setEnvironmentColor(color, intensity);
}

function clearEnvMap() {
    if (!viewer) return;
    try {
        // æ¸…é™¤ scene.environment å¹¶æ¢å¤å®¹å™¨èƒŒæ™¯
        if (viewer._currentEnvMap) {
            try { viewer._currentEnvMap.dispose(); } catch (e) {}
            viewer._currentEnvMap = null;
        }
        if (viewer.scene) {
            viewer.scene.environment = null;
            viewer.scene.background = null;
        }
        const statusEl = document.getElementById('hdriStatus');
        if (statusEl) statusEl.textContent = 'å·²æ¸…é™¤ç¯å¢ƒè´´å›¾';
        viewer.showMessage('å·²æ¸…é™¤ç¯å¢ƒè´´å›¾', 'success');
        // é‡æ–°å¯ç”¨é¢œè‰²æ§ä»¶
        const colorEl = document.getElementById('envColorPicker');
        const intensityEl = document.getElementById('envColorIntensity');
        if (colorEl) colorEl.disabled = false;
        if (intensityEl) intensityEl.disabled = false;
    } catch (e) {
        console.error('æ¸…é™¤ç¯å¢ƒè´´å›¾å¤±è´¥', e);
        viewer.showMessage('æ¸…é™¤ç¯å¢ƒè´´å›¾å¤±è´¥', 'error');
    }
}

// HDRI å¯è§æ€§ä¸å˜æ¢å…¨å±€å›è°ƒ
// HDRI å˜æ¢å·²ç§»é™¤ï¼Œä¿ç•™åŠ è½½ä¸æ˜¾ç¤ºæ§åˆ¶

function createLightUI(id, label, intensity = 1, color = '#ffffff') {
    const list = document.getElementById('lightsList');
    if (!list) return;
    // é¿å…é‡å¤åˆ›å»º
    if (document.getElementById(`light-ui-${id}`)) return;
    const container = document.createElement('div');
    container.id = `light-ui-${id}`;
    container.style.padding = '8px';
    container.style.marginBottom = '8px';
    container.style.background = 'rgba(255,255,255,0.9)';
    container.style.borderRadius = '6px';
    container.innerHTML = `
        <div style="font-weight:bold;">${label}</div>
        å¼ºåº¦: <input type="range" min="0" max="4" step="0.05" value="${intensity}" id="int-${id}" /> <span id="int-val-${id}">${Number(intensity).toFixed(2)}</span><br/>
        é¢œè‰²: <input type="color" id="col-${id}" value="${color}" />
        <button id="del-${id}" style="margin-left:8px;">åˆ é™¤</button>
    `;
    list.appendChild(container);

    const intEl = document.getElementById(`int-${id}`);
    const intVal = document.getElementById(`int-val-${id}`);
    const colEl = document.getElementById(`col-${id}`);
    const delBtn = document.getElementById(`del-${id}`);

    intEl.addEventListener('input', (e) => {
        const v = Number(e.target.value);
        intVal.textContent = v.toFixed(2);
        if (viewer) viewer.setLightIntensity(id, v);
    });
    colEl.addEventListener('input', (e) => {
        if (viewer) viewer.setLightColor(id, e.target.value);
    });
    delBtn.addEventListener('click', () => {
        if (viewer) viewer.removeLight(id);
        container.remove();
    });
}

// åˆ‡æ¢å››è§†å›¾ï¼ˆç”±é¡µé¢æŒ‰é’®è°ƒç”¨ï¼‰
// å››è§†å›¾å·²ç§»é™¤

// åˆ‡æ¢ç¯å…‰åŠ©æ‰‹æ˜¾ç¤ºï¼ˆHTML è°ƒç”¨ï¼‰
function toggleLightHelpers(checked) {
    if (!viewer) return;
    viewer.setHelpersVisible(!!checked);
}

    // åˆ‡æ¢åœ°é¢ç½‘æ ¼æ˜¾ç¤ºï¼ˆHTML è°ƒç”¨ï¼‰
    function toggleGrid(checked) {
        if (!viewer) return;
        viewer.setGridVisible(!!checked);
    }

// Transform æ§åˆ¶çš„å…¨å±€æ¥å£ï¼ˆä¾› HTML æŒ‰é’®è°ƒç”¨ï¼‰
function toggleTransform() {
    if (viewer) viewer.toggleTransform();
}

function setTransformMode(mode) {
    if (viewer) viewer.setTransformMode(mode);
}

function toggleUniformScale(checked) {
    if (viewer) viewer.setUniformScale(!!checked);
}

function toggleUniformAlign(checked) {
    if (viewer) viewer.setUniformAlign(!!checked);
}

// æ‘„åƒæœº UI å›è°ƒï¼ˆç”±é¡µé¢æ§ä»¶è°ƒç”¨ï¼‰
function setCameraFovFromUI(val) {
    if (!viewer) return;
    const f = Number(val);
    if (isNaN(f)) return;
    viewer.setCameraFov(f);
}

function setCameraFocalFromUI(val) {
    if (!viewer) return;
    const f = Number(val);
    if (isNaN(f)) return;
    viewer.setCameraFocalLengthMm(f);
}

// æˆªå±æ¡† UI å›è°ƒ
function toggleCaptureFrame(checked) {
    if (!viewer) return;
    viewer.setCaptureFrameVisible(!!checked);
}

function setCaptureFrameWidth(val) {
    const v = Number(val);
    const range = document.getElementById('captureWidthRange');
    const input = document.getElementById('captureWidthInput');
    if (range) range.value = v;
    if (input) input.value = v;
    if (viewer) viewer.setCaptureFrameSize(v, viewer.captureFrameSize ? viewer.captureFrameSize.hPct : 60);
}

function setCaptureFrameHeight(val) {
    const v = Number(val);
    const range = document.getElementById('captureHeightRange');
    const input = document.getElementById('captureHeightInput');
    if (range) range.value = v;
    if (input) input.value = v;
    if (viewer) viewer.setCaptureFrameSize(viewer.captureFrameSize ? viewer.captureFrameSize.wPct : 60, v);
}

function exportCapture() {
    if (!viewer) return;
    viewer.exportCaptureImage();
}

function saveScreenshotToServer() {
    if (!viewer) return;
    try {
        // å›ºå®š tokenï¼Œåç«¯ä¼šæ ¹æ®ä¸Šä¼ ä¿å­˜ä¸º image.png
        const token = 'image';
        try { location.hash = '#capture:' + token; } catch (e) {}
        if (typeof viewer.exportCaptureImage === 'function') {
            viewer.exportCaptureImage();
        } else if (typeof window.viewer !== 'undefined' && window.viewer && typeof window.viewer.exportCaptureImage === 'function') {
            window.viewer.exportCaptureImage();
        }
    } catch (e) {
        console.error('saveScreenshotToServer failed', e);
    }
}

function toggleCaptureUsePixels(checked) {
    const usePx = !!checked;
    const widthRange = document.getElementById('captureWidthRange');
    const heightRange = document.getElementById('captureHeightRange');
    const widthInput = document.getElementById('captureWidthInput');
    const heightInput = document.getElementById('captureHeightInput');
    const widthPx = document.getElementById('captureWidthPx');
    const heightPx = document.getElementById('captureHeightPx');
    if (usePx) {
        // switch to pixels: hide pct ranges, set px inputs to current overlay size
        if (widthRange) widthRange.disabled = true;
        if (heightRange) heightRange.disabled = true;
        if (widthInput) widthInput.disabled = true;
        if (heightInput) heightInput.disabled = true;
        if (viewer && viewer.captureFrameEl) {
            const rect = viewer.captureFrameEl.getBoundingClientRect();
            if (widthPx) widthPx.value = Math.round(rect.width);
            if (heightPx) heightPx.value = Math.round(rect.height);
        }
    } else {
        if (widthRange) widthRange.disabled = false;
        if (heightRange) heightRange.disabled = false;
        if (widthInput) widthInput.disabled = false;
        if (heightInput) heightInput.disabled = false;
    }
}

function setCaptureFrameWidthPx(val) {
    const v = Number(val);
    const pxInput = document.getElementById('captureWidthPx');
    if (pxInput) pxInput.value = v;
    if (viewer) viewer.setCaptureFrameSizePx(v, viewer.captureFrameSize ? viewer.captureFrameSize.hPx : 600);
}

function setCaptureFrameHeightPx(val) {
    const v = Number(val);
    const pxInput = document.getElementById('captureHeightPx');
    if (pxInput) pxInput.value = v;
    if (viewer) viewer.setCaptureFrameSizePx(viewer.captureFrameSize ? viewer.captureFrameSize.wPx : 800, v);
}

function toggleCaptureIncludeBg(checked) {
    if (!viewer) return;
    viewer.setCaptureIncludeBackground(!!checked);
}

// æ¨¡å‹å°ºå¯¸æ§åˆ¶
function updateModelTargetSize(value) {
    const v = Number(value);
    const el = document.getElementById('modelSizeVal');
    if (el) el.textContent = v.toFixed(1);
    if (viewer) viewer.setModelTargetSize(v);
}

function setModelTargetSize(value) {
    const v = Number(value);
    const slider = document.querySelector('input[oninput*="updateModelTargetSize"]');
    if (slider) slider.value = v;
    updateModelTargetSize(v);
}

// åˆ‡æ¢é»˜è®¤æ–¹å‘å…‰æ˜¾ç¤º
// (å·²ç§»é™¤ï¼šé»˜è®¤æ–¹å‘å…‰/ç‚¹å…‰å¼€å…³)

// æŒ‡é’ˆå¯¹å…‰æ ‡äº¤äº’çš„å®ç°
ModelViewer.prototype._onPointerDown = function (event) {
    // æ£€æŸ¥æ‰€æœ‰ç”¨æˆ·ç¯å…‰çš„ helper æ˜¯å¦è¢«ç‚¹å‡»
    const helpers = Object.values(this.userLights).map(u => u.helper).filter(Boolean);
    if (!helpers.length) return;
    const rect = this.renderer.domElement.getBoundingClientRect();
    this.pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    this.pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    this.raycaster.setFromCamera(this.pointer, this.camera);
    const intersects = this.raycaster.intersectObjects(helpers, true);
    if (intersects.length > 0) {
        const hitHelper = intersects[0].object;
        // æ‰¾åˆ°å¯¹åº”çš„ light id
        const entry = Object.values(this.userLights).find(u => u.helper === hitHelper || (u.helper && u.helper.uuid === hitHelper.uuid));
        if (!entry) return;
        this.draggingLightId = entry.id;
        // è®°å½•ä¸ºå½“å‰é€‰ä¸­ç¯å…‰
        this.selectedLightId = entry.id;
        // å¼€å§‹æ‹–æ‹½ï¼šæ ‡è®°ã€ç¦ç”¨ç›¸æœºæ§åˆ¶ï¼Œé˜²æ­¢è§†å›¾éšæŒ‡é’ˆç§»åŠ¨
        this.isDraggingLight = true;
        if (this.controls) this.controls.enabled = false;
        // é˜»æ­¢é»˜è®¤å’Œå†’æ³¡ï¼Œé¿å…OrbitControlsä¹Ÿå¤„ç†æ­¤äº‹ä»¶
        if (event && event.preventDefault) event.preventDefault();
        if (event && event.stopPropagation) event.stopPropagation();
        // è®¾ç½®å¹³é¢ä¸ºé¢å‘ç›¸æœºçš„å¹³é¢å¹¶è¿‡å…‰æ ‡ç‚¹
        const camDir = new THREE.Vector3();
        this.camera.getWorldDirection(camDir);
        // å¹³é¢æ³•çº¿æœå‘ç›¸æœºæ–¹å‘çš„åå‘ï¼Œè¿™æ ·å¹³é¢é¢å‘æ‘„åƒæœº
        this.dragPlane.setFromNormalAndCoplanarPoint(camDir.clone().negate(), entry.helper.position);
        // è®¡ç®—åç§»é‡
        const intersectPoint = new THREE.Vector3();
        this.raycaster.ray.intersectPlane(this.dragPlane, intersectPoint);
        this.dragOffset.copy(intersectPoint).sub(entry.helper.position);
        this.renderer.domElement.style.cursor = 'grabbing';
    }
};

ModelViewer.prototype._onPointerMove = function (event) {
    const rect = this.renderer.domElement.getBoundingClientRect();
    this.pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    this.pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    if (!this.isDraggingLight) return;
    this.raycaster.setFromCamera(this.pointer, this.camera);
    const intersectPoint = new THREE.Vector3();
    if (this.raycaster.ray.intersectPlane(this.dragPlane, intersectPoint)) {
        const newPos = intersectPoint.sub(this.dragOffset);
        // æ ¹æ®å½“å‰æ‹–æ‹½çš„ light id æ›´æ–°å¯¹åº”çš„ light å’Œ helper
        const entry = this.userLights[this.draggingLightId];
        if (!entry) return;
        if (entry.helper) entry.helper.position.copy(newPos);
        if (entry.light) {
            entry.light.position.copy(newPos);
            if (entry.type === 'directional' && entry.light.target) {
                entry.light.target.position.set(0, 0, 0);
                entry.light.target.updateMatrixWorld();
            }
        }
        // æ›´æ–°å¯¹åº”UIï¼Œå¦‚æœè¯¥UIä½¿ç”¨é€šç”¨ dirX/Y/Z åˆ™æ›´æ–°ä¸ºå½“å‰ dragged light if matches default directional
        const dirX = document.getElementById('dirX');
        const dirY = document.getElementById('dirY');
        const dirZ = document.getElementById('dirZ');
        if (dirX && dirY && dirZ && entry && entry.type === 'directional') {
            dirX.value = entry.light.position.x.toFixed(2);
            dirY.value = entry.light.position.y.toFixed(2);
            dirZ.value = entry.light.position.z.toFixed(2);
        }
    }
};

ModelViewer.prototype._onPointerUp = function () {
    if (this.isDraggingLight) {
        this.isDraggingLight = false;
        // æ‹–æ‹½ç»“æŸï¼šæ¢å¤ç›¸æœºæ§åˆ¶
        if (this.controls) this.controls.enabled = true;
        this.renderer.domElement.style.cursor = 'default';
    }
};

// ç‚¹å‡»ç”»å¸ƒç©ºç™½å¤„å–æ¶ˆé€‰æ‹©
ModelViewer.prototype._onCanvasPointerDown = function (event) {
    // compute pointer
    const rect = this.renderer.domElement.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    this.raycaster.setFromCamera({ x, y }, this.camera);

    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åˆ°ç¯å…‰ helperï¼ˆé¿å…ä¸å…¶å†²çªï¼‰
    const helpers = Object.values(this.userLights).map(u => u.helper).filter(Boolean);
    const hitsHelpers = helpers.length ? this.raycaster.intersectObjects(helpers, true) : [];
    if (hitsHelpers && hitsHelpers.length > 0) return; // ç‚¹ä¸­äº† helperï¼Œä¸å–æ¶ˆé€‰æ‹©

    // å¦‚æœå¯ç”¨äº† TransformControlsï¼Œåˆ™ä¸è¦åœ¨ pointerdown åšé€‰æ‹©ï¼ˆé¿å…å’Œå˜æ¢å†²çªï¼‰
    if (this.transformEnabled) {
        return;
    }

    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åˆ°æ¨¡å‹ï¼ˆè‹¥ç‚¹å‡»æ¨¡å‹åˆ™é€‰ä¸­ï¼‰
    const modelObjects = this.models.map(m => m.object).filter(Boolean);
    const hitsModels = modelObjects.length ? this.raycaster.intersectObjects(modelObjects, true) : [];
    if (hitsModels && hitsModels.length > 0) {
        // æ‰¾åˆ°è¢«ç‚¹å‡»çš„å­å¯¹è±¡ï¼Œå‘ä¸Šå¯»æ‰¾å¸¦æœ‰ modelId çš„æ ¹å¯¹è±¡
        let obj = hitsModels[0].object;
        while (obj) {
            if (obj.userData && obj.userData._modelId) {
                this.selectModel(obj.userData._modelId, true);
                return;
            }
            obj = obj.parent;
        }
        // å¤‡é€‰ï¼šå¦‚æœæœªæ‰¾åˆ° userDataï¼Œåˆ™åŒ¹é… models åˆ—è¡¨ä¸­çš„æ ¹å¯¹è±¡
        const hitRoot = hitsModels[0].object;
        for (const m of this.models) {
            let p = hitsModels[0].object;
            while (p) {
                if (p === m.object) {
                    this.selectModel(m.id, true);
                    return;
                }
                p = p.parent;
            }
        }
        return;
    }

    // æœªå‘½ä¸­ä»»ä½•å¯¹è±¡ï¼šå–æ¶ˆé€‰æ‹©
    this.deselectModel();
};

// åœ¨ pointerup æ—¶å¤„ç†é€‰æ‹©ï¼ˆç”¨äºä¸ TransformControls åè°ƒï¼‰
ModelViewer.prototype._onCanvasPointerUp = function (event) {
    // å¦‚æœåœ¨æ‹–æ‹½ transform æˆ–ç¯å…‰æ—¶ï¼Œå¿½ç•¥é€‰æ‹©
    if (this.isTransformDragging || this.isDraggingLight) return;

    const rect = this.renderer.domElement.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    this.raycaster.setFromCamera({ x, y }, this.camera);

    const helpers = Object.values(this.userLights).map(u => u.helper).filter(Boolean);
    const hitsHelpers = helpers.length ? this.raycaster.intersectObjects(helpers, true) : [];
    if (hitsHelpers && hitsHelpers.length > 0) return;

    const modelObjects = this.models.map(m => m.object).filter(Boolean);
    const hitsModels = modelObjects.length ? this.raycaster.intersectObjects(modelObjects, true) : [];
    if (hitsModels && hitsModels.length > 0) {
        // é€‰æ‹©æ¨¡å‹ï¼ˆå¦‚æœ transformEnabled åˆ™ attachï¼‰
        let obj = hitsModels[0].object;
        while (obj) {
            if (obj.userData && obj.userData._modelId) {
                    this.selectModel(obj.userData._modelId, true);
                return;
            }
            obj = obj.parent;
        }
        for (const m of this.models) {
            let p = hitsModels[0].object;
            while (p) {
                if (p === m.object) {
                    this.selectModel(m.id, true);
                    return;
                }
                p = p.parent;
            }
        }
        return;
    }

    // æœªå‘½ä¸­ä»»ä½•å¯¹è±¡ï¼šå–æ¶ˆé€‰æ‹©
    this.deselectModel();
    // å››è§†å›¾åŠŸèƒ½å·²ç§»é™¤ï¼Œæ¢å¤é€»è¾‘ä¸éœ€è¦
};

ModelViewer.prototype.deselectModel = function () {
    // ç§»é™¤é€‰æ‹©æ¡†è¾…åŠ©
    if (this.selectionBox) {
        try { this.scene.remove(this.selectionBox); } catch (e) {}
        this.selectionBox = null;
    }
    // detach transform controls if attached
    if (this.transformControls) {
        try { this.transformControls.detach(); } catch (e) {}
        this.transformControls.visible = false;
    }
    this.currentModel = null;
    // æ›´æ–°ä¾§æ ä¸­çš„æŒ‰é’®/çŠ¶æ€æ–‡æœ¬ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    this.updateFileList();
};

// å¤„ç† Delete é”®ï¼šåˆ é™¤å½“å‰é€‰ä¸­çš„æ¨¡å‹æˆ–ç¯å…‰
ModelViewer.prototype._handleDeleteKey = function () {
    // ä¼˜å…ˆåˆ é™¤è¢«é€‰ä¸­çš„ç¯å…‰ï¼ˆå¦‚æœé€‰ä¸­ç¯å…‰ï¼‰
    if (this.selectedLightId) {
        // å¦‚æœæ­£æ‹–æ‹½ç¯å…‰åˆ™å¿½ç•¥
        if (this.isDraggingLight) return;
        this.removeLight(this.selectedLightId);
        this.selectedLightId = null;
        this.updateFileList();
        return;
    }

    // åˆ é™¤é€‰ä¸­æ¨¡å‹
    if (this.currentModel) {
        // æ‰¾ model id
        const id = this.currentModel.userData && this.currentModel.userData._modelId;
        if (id) {
            this.removeModel(id);
        } else {
            // æ‰¾åˆ°å¯¹åº” models åˆ—è¡¨ä¸­çš„æ¡ç›®
            const entry = this.models.find(m => m.object === this.currentModel);
            if (entry) this.removeModel(entry.id);
        }
        this.currentModel = null;
        this._updateSelectionHelper();
        return;
    }
};

// ========================================
// å·¥ç¨‹æ–‡ä»¶ä¿å­˜å’ŒåŠ è½½åŠŸèƒ½
// ========================================

// ä¿å­˜å·¥ç¨‹æ–‡ä»¶
ModelViewer.prototype.saveProject = function() {
    // ä¼˜å…ˆä½¿ç”¨ File System Access API çš„æ–‡ä»¶å¥æŸ„è¿›è¡Œè¦†ç›–ä¿å­˜ï¼ˆæ— æç¤ºï¼‰
    if (this.currentProjectFileHandle && window.showSaveFilePicker) {
        // write and keep handle
        this._writeProjectFileHandle(this.currentProjectFileHandle).then(() => {
            this.hasUnsavedChanges = false;
            try { updateProjectStatus(); } catch (e) {}
            console.log('å·¥ç¨‹æ–‡ä»¶è¦†ç›–ä¿å­˜æˆåŠŸ (é€šè¿‡å¥æŸ„)');
        }).catch((err) => {
            console.error('é€šè¿‡å¥æŸ„è¦†ç›–ä¿å­˜å¤±è´¥:', err);
            // fallback åˆ°ä¼ ç»Ÿä¸‹è½½
            if (this.currentProjectFileName) this.saveProjectToFile(this.currentProjectFileName);
        });
        return;
    }

    if (this.currentProjectFileName) {
        // å¦‚æœå·²æœ‰ä¿å­˜çš„æ–‡ä»¶åï¼ˆä½†æ²¡æœ‰å¥æŸ„ï¼‰ï¼Œæ˜¾ç¤ºæç¤ºåä¸‹è½½åŒåæ–‡ä»¶
        if (confirm(`å°†ä¿å­˜å·¥ç¨‹æ–‡ä»¶ "${this.currentProjectFileName}" åˆ°ä¸‹è½½æ–‡ä»¶å¤¹ã€‚\n\nç”±äºæµè§ˆå™¨é™åˆ¶ï¼Œæ— æ³•ç›´æ¥è¦†ç›–åŸæ–‡ä»¶ï¼Œè¯·æ‰‹åŠ¨å°†ä¸‹è½½çš„æ–‡ä»¶æ›¿æ¢åŸæ¥çš„å·¥ç¨‹æ–‡ä»¶ã€‚\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`)) {
            this.saveProjectToFile(this.currentProjectFileName);
        }
    } else {
        // ç¬¬ä¸€æ¬¡ä¿å­˜ï¼Œéœ€è¦é€‰æ‹©æ–‡ä»¶å/å¥æŸ„
        this.saveProjectAs();
    }
};

// å¦å­˜ä¸ºå·¥ç¨‹æ–‡ä»¶ï¼ˆä¼šå°è¯•ä½¿ç”¨ File System Access APIï¼‰
ModelViewer.prototype.saveProjectAs = async function() {
    try {
        console.log('å¼€å§‹å¦å­˜ä¸ºå·¥ç¨‹æ–‡ä»¶...');

        // å¦‚æœå·²æœ‰æ–‡ä»¶åï¼Œä½¿ç”¨ç›¸åŒçš„æ–‡ä»¶åä½œä¸ºå»ºè®®ï¼Œå¦åˆ™ç”Ÿæˆæ–°æ–‡ä»¶å
        const suggestedName = this.currentProjectFileName || (() => {
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            return `bb3d-project-${timestamp}.bbproject`;
        })();

        // å¦‚æœæµè§ˆå™¨æ”¯æŒ File System Access APIï¼Œä¼˜å…ˆä½¿ç”¨ showSaveFilePicker è·å–å¥æŸ„
        if (window.showSaveFilePicker) {
            try {
                const opts = [{
                    description: 'BB 3D é¡¹ç›®',
                    accept: { 'application/json': ['.bbproject'] }
                }];
                const handle = await window.showSaveFilePicker({
                    suggestedName,
                    types: opts
                });
                await this._writeProjectFileHandle(handle);
                this.currentProjectFileHandle = handle;
                this.currentProjectFileName = handle.name || suggestedName;
                this.hasUnsavedChanges = false;
                // æŒä¹…åŒ–å¥æŸ„ä»¥ä¾¿åç»­ä¼šè¯æ¢å¤
                try { await this._persistCurrentHandle(); } catch (e) { console.warn('æŒä¹…åŒ–å¥æŸ„å¤±è´¥', e); }
                console.log('é€šè¿‡ File System Access API ä¿å­˜å·¥ç¨‹æˆåŠŸ');
                return;
            } catch (err) {
                console.warn('ä½¿ç”¨ showSaveFilePicker ä¿å­˜å¤±è´¥ï¼Œå›é€€åˆ°ä¸‹è½½ï¼š', err);
                // fall through to download fallback
            }
        }

        // å›é€€ï¼šåˆ›å»ºä¸‹è½½æ–‡ä»¶
        this.saveProjectToFile(suggestedName);
        this.currentProjectFileName = suggestedName;

    } catch (error) {
        console.error('å¦å­˜ä¸ºå·¥ç¨‹æ–‡ä»¶å¤±è´¥:', error);
        alert('å¦å­˜ä¸ºå·¥ç¨‹æ–‡ä»¶å¤±è´¥: ' + error.message);
    }
};

// å†…éƒ¨ï¼šæ„å»ºè¦ä¿å­˜çš„é¡¹ç›®æ•°æ®å¯¹è±¡
ModelViewer.prototype._buildProjectData = function() {
    return {
        version: '1.0',
        timestamp: new Date().toISOString(),
        metadata: {
            app: 'BB 3DæŸ¥çœ‹å™¨',
            description: '3Dæ¨¡å‹æŸ¥çœ‹å™¨å·¥ç¨‹æ–‡ä»¶'
        },
        scene: this.serializeScene(),
        camera: this.serializeCamera(),
        models: this.serializeModels(),
        lights: this.serializeLights(),
        settings: this.serializeSettings()
    };
};

// ç”ŸæˆåŒ…å«æ¨¡å‹äºŒè¿›åˆ¶çš„ ZIP Blobï¼ˆmetadata.json + files/...ï¼‰
ModelViewer.prototype._buildProjectZipBlob = async function() {
    try {
        const meta = this._buildProjectData();

        // å‡†å¤‡æ–‡ä»¶æ¡ç›®
        const entries = {};

        // éå†æ¨¡å‹ï¼Œæ”¶é›†æ–‡ä»¶æ•°æ®
        for (let i = 0; i < this.models.length; i++) {
            const m = this.models[i];
            if (m && m.file && m.fileName) {
                try {
                    const arrayBuffer = await m.file.arrayBuffer();
                    const uint8 = new Uint8Array(arrayBuffer);
                    // ä¸ºé¿å…åŒåå†²çªï¼Œä½¿ç”¨ id_æ–‡ä»¶å
                    const entryName = `files/${m.id}_${m.fileName}`;
                    entries[entryName] = uint8;
                    // åœ¨ metadata ä¸­è®°å½•è¯¥æ¨¡å‹å¯¹åº”çš„æ–‡ä»¶ entry
                    const metaModel = meta.models.find(x => x.id === m.id || x.fileName === m.fileName);
                    if (metaModel) {
                        metaModel.fileEntry = entryName;
                    }
                } catch (e) {
                    console.warn('è¯»å–æ¨¡å‹æ–‡ä»¶å¤±è´¥ï¼Œè·³è¿‡åµŒå…¥:', m.fileName, e);
                }
            }
        }

        // å°† metadata å†™å…¥ ZIP æ ¹ç›®å½•çš„ metadata.json
        const metaStr = JSON.stringify(meta, null, 2);
        entries['metadata.json'] = new TextEncoder().encode(metaStr);

        // ä½¿ç”¨ fflate è¿›è¡Œæ‰“åŒ…ï¼ˆè¿”å› Uint8Arrayï¼‰
        if (typeof fflate === 'undefined' || !fflate.zipSync) {
            throw new Error('fflate ä¸å¯ç”¨ï¼Œæ— æ³•ç”Ÿæˆ ZIP');
        }
        const zipUint8 = fflate.zipSync(entries);
        return new Blob([zipUint8], { type: 'application/zip' });
    } catch (e) {
        console.error('æ„å»ºé¡¹ç›® ZIP å¤±è´¥', e);
        throw e;
    }
};

// ä½¿ç”¨ FileSystemFileHandle å†™å…¥æ–‡ä»¶ï¼ˆFS APIï¼‰
ModelViewer.prototype._writeProjectFileHandle = async function(handle) {
    try {
        // ä¼˜å…ˆç”Ÿæˆ zip åŒ…å«æ¨¡å‹äºŒè¿›åˆ¶å’Œ metadata.json
        const zipBlob = await this._buildProjectZipBlob();
        const writable = await handle.createWritable();
        await writable.write(zipBlob);
        await writable.close();
        // æ›´æ–°çŠ¶æ€
        this.hasUnsavedChanges = false;
        this.currentProjectFileName = handle.name || this.currentProjectFileName;
        console.log('å†™å…¥åˆ°å¥æŸ„å®Œæˆ:', this.currentProjectFileName);
    } catch (err) {
        console.error('å†™å…¥å¥æŸ„å¤±è´¥:', err);
        throw err;
    }
};

// å®é™…çš„æ–‡ä»¶ä¿å­˜é€»è¾‘ï¼ˆä¸‹è½½å›é€€ï¼‰
ModelViewer.prototype.saveProjectToFile = function(fileName) {
    try {
        console.log('ä¿å­˜å·¥ç¨‹æ–‡ä»¶åˆ°:', fileName);
        // ç”Ÿæˆ zip åŒ…å«æ¨¡å‹äºŒè¿›åˆ¶å’Œ metadata.json
        this._buildProjectZipBlob().then((zipBlob) => {
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }).catch((err) => {
            console.warn('ç”Ÿæˆ ZIP å¤±è´¥ï¼Œå›é€€åˆ° JSON å¯¼å‡ºï¼š', err);
            const projectData = this._buildProjectData();
            const jsonStr = JSON.stringify(projectData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        });

        // æ ‡è®°ä¸ºå·²ä¿å­˜çŠ¶æ€
        this.hasUnsavedChanges = false;
        this.currentProjectFileName = fileName;

        console.log('å·¥ç¨‹æ–‡ä»¶ä¿å­˜æˆåŠŸ');

    } catch (error) {
        console.error('ä¿å­˜å·¥ç¨‹æ–‡ä»¶å¤±è´¥:', error);
        alert('ä¿å­˜å·¥ç¨‹æ–‡ä»¶å¤±è´¥: ' + error.message);
    }
};

// ================================
// IndexedDB: æŒä¹…åŒ– FileSystemFileHandle
// ================================

ModelViewer.prototype._openHandleDB = function() {
    return new Promise((resolve, reject) => {
        if (!window.indexedDB) return resolve(null);
        const req = indexedDB.open('bb3d-filehandles', 1);
        req.onupgradeneeded = function(e) {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('handles')) {
                db.createObjectStore('handles');
            }
        };
        req.onsuccess = function(e) {
            resolve(e.target.result);
        };
        req.onerror = function(e) {
            console.warn('æ‰“å¼€ IndexedDB å¤±è´¥', e);
            resolve(null);
        };
    });
};

ModelViewer.prototype._saveHandleToDB = async function(key, handle) {
    try {
        const db = await this._openHandleDB();
        if (!db) return false;
        return new Promise((resolve, reject) => {
            const tx = db.transaction('handles', 'readwrite');
            const store = tx.objectStore('handles');
            const req = store.put(handle, key);
            req.onsuccess = function() {
                resolve(true);
            };
            req.onerror = function(e) {
                console.warn('ä¿å­˜å¥æŸ„åˆ° IndexedDB å¤±è´¥', e);
                resolve(false);
            };
        });
    } catch (e) {
        console.warn('ä¿å­˜å¥æŸ„å¼‚å¸¸', e);
        return false;
    }
};

ModelViewer.prototype._getHandleFromDB = async function(key) {
    try {
        const db = await this._openHandleDB();
        if (!db) return null;
        return new Promise((resolve, reject) => {
            const tx = db.transaction('handles', 'readonly');
            const store = tx.objectStore('handles');
            const req = store.get(key);
            req.onsuccess = function(e) {
                resolve(e.target.result || null);
            };
            req.onerror = function(e) {
                console.warn('ä» IndexedDB è¯»å–å¥æŸ„å¤±è´¥', e);
                resolve(null);
            };
        });
    } catch (e) {
        console.warn('è¯»å–å¥æŸ„å¼‚å¸¸', e);
        return null;
    }
};

// åœ¨æˆåŠŸè·å–/ä½¿ç”¨å¥æŸ„åæŒä¹…åŒ–å®ƒ
ModelViewer.prototype._persistCurrentHandle = async function() {
    try {
        if (!this.currentProjectFileHandle) return;
        await this._saveHandleToDB('project', this.currentProjectFileHandle);
    } catch (e) {
        console.warn('æŒä¹…åŒ–å¥æŸ„å¤±è´¥', e);
    }
};

// æ¢å¤ä¹‹å‰ä¿å­˜çš„å¥æŸ„ï¼ˆå¦‚æœæœ‰æƒé™åˆ™è®¾ç½®ä¸ºå½“å‰å¥æŸ„ï¼‰
ModelViewer.prototype.restoreSavedProjectHandle = async function() {
    try {
        if (!window.indexedDB || !window.showSaveFilePicker) return;
        const handle = await this._getHandleFromDB('project');
        if (!handle) return null;

        // æ£€æŸ¥æƒé™ï¼ˆå¦‚æœéœ€è¦è¯·æ±‚å†™å…¥æƒé™ï¼‰
        let permission = 'denied';
        try {
            if (typeof handle.queryPermission === 'function') {
                const q = await handle.queryPermission({ mode: 'readwrite' });
                if (q === 'granted') permission = 'granted';
                else {
                    const req = await handle.requestPermission({ mode: 'readwrite' });
                    permission = req === 'granted' ? 'granted' : 'denied';
                }
            } else {
                // æ—§ç‰ˆå®ç°ï¼šå°è¯• requestPermission
                if (typeof handle.requestPermission === 'function') {
                    const req = await handle.requestPermission({ mode: 'readwrite' });
                    permission = req === 'granted' ? 'granted' : 'denied';
                } else {
                    // æ— æŸ¥è¯¢æ¥å£ï¼Œä¹è§‚è®¾ç½®ä¸º grantedï¼ˆæµè§ˆå™¨ä¼šåœ¨å†™å…¥æ—¶æŠ›å‡ºï¼‰
                    permission = 'granted';
                }
            }
        } catch (e) {
            console.warn('æ£€æŸ¥/è¯·æ±‚å¥æŸ„æƒé™å¤±è´¥', e);
            permission = 'denied';
        }

        if (permission === 'granted') {
            this.currentProjectFileHandle = handle;
            this.currentProjectFileName = handle.name || this.currentProjectFileName;
            this.hasUnsavedChanges = false;
            console.log('æ¢å¤å¹¶è®¾ç½®äº†å·²ä¿å­˜çš„å·¥ç¨‹å¥æŸ„:', this.currentProjectFileName);
            return handle;
        } else {
            console.warn('æ²¡æœ‰æƒé™è®¿é—®ä¿å­˜çš„å·¥ç¨‹å¥æŸ„');
            return null;
        }
    } catch (e) {
        console.warn('æ¢å¤ä¿å­˜å¥æŸ„å¼‚å¸¸', e);
        return null;
    }
};

// è¯·æ±‚ç”¨æˆ·é€‰æ‹©å·¥ç¨‹æ–‡ä»¶å¹¶æŒä¹…åŒ–å¥æŸ„ä»¥æ”¯æŒè¦†ç›–ä¿å­˜ï¼ˆä»…åœ¨æ”¯æŒçš„æµè§ˆå™¨ä¸­ç”Ÿæ•ˆï¼‰
ModelViewer.prototype.requestAndPersistHandle = async function(expectedName) {
    if (!window.showOpenFilePicker) return null;
    try {
        const [handle] = await window.showOpenFilePicker({
            types: [{
                description: 'BB 3D å·¥ç¨‹',
                accept: { 'application/octet-stream': ['.bbproject'] }
            }],
            multiple: false
        });

        if (!handle) return null;

        // å¯é€‰ï¼šæ ¡éªŒæ–‡ä»¶åæ˜¯å¦ä¸å½“å‰æ‰“å¼€çš„å·¥ç¨‹ä¸€è‡´
        if (expectedName && handle.name !== expectedName) {
            // ä¸é˜»æ­¢ï¼Œä½†ç»™å‡ºæç¤º
            console.warn('é€‰æ‹©çš„æ–‡ä»¶åä¸å½“å‰å·¥ç¨‹æ–‡ä»¶åä¸ä¸€è‡´:', handle.name, '!=', expectedName);
        }

        // è¯·æ±‚è¯»å†™æƒé™
        try {
            if (typeof handle.requestPermission === 'function') {
                const req = await handle.requestPermission({ mode: 'readwrite' });
                if (req !== 'granted') {
                    console.warn('ç”¨æˆ·æœªæˆäºˆå†™æƒé™');
                    return null;
                }
            } else if (typeof handle.queryPermission === 'function') {
                const q = await handle.queryPermission({ mode: 'readwrite' });
                if (q !== 'granted') {
                    const r = await handle.requestPermission({ mode: 'readwrite' });
                    if (r !== 'granted') {
                        console.warn('ç”¨æˆ·æœªæˆäºˆå†™æƒé™');
                        return null;
                    }
                }
            }
        } catch (permErr) {
            console.warn('è¯·æ±‚å†™æƒé™å¤±è´¥', permErr);
            return null;
        }

        // è®¾ç½®å¹¶æŒä¹…åŒ–
        this.currentProjectFileHandle = handle;
        this.currentProjectFileName = handle.name || this.currentProjectFileName;
        try { await this._persistCurrentHandle(); } catch (e) { console.warn('æŒä¹…åŒ–å¥æŸ„å¤±è´¥', e); }
        this.hasUnsavedChanges = false;
        console.log('å·²è·å–å¹¶æŒä¹…åŒ–æ–‡ä»¶å¥æŸ„:', this.currentProjectFileName);
        return handle;
    } catch (e) {
        console.warn('è¯·æ±‚æ–‡ä»¶å¥æŸ„è¢«å–æ¶ˆæˆ–å¤±è´¥', e);
        return null;
    }
};

// åŠ è½½å·¥ç¨‹æ–‡ä»¶
ModelViewer.prototype.loadProject = function(file) {
    try {
        console.log('å¼€å§‹åŠ è½½å·¥ç¨‹æ–‡ä»¶...');

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                let projectData = null;
                let embeddedFilesMap = null;
                // å°è¯•ä»¥ ArrayBuffer è§£æä¸º ZIP
                try {
                    const buf = e.target.result;
                    const uint8 = new Uint8Array(buf);
                    if (typeof fflate !== 'undefined' && fflate.unzipSync) {
                        const entries = fflate.unzipSync(uint8);
                        if (entries && (entries['metadata.json'] || entries['project.json'])) {
                            const metaName = entries['metadata.json'] ? 'metadata.json' : 'project.json';
                            const metaStr = new TextDecoder().decode(entries[metaName]);
                            projectData = JSON.parse(metaStr);
                            // æ„å»ºæ–‡ä»¶æ˜ å°„ï¼ˆentryName -> Fileï¼‰
                            embeddedFilesMap = {};
                            Object.keys(entries).forEach(k => {
                                if (k.startsWith('files/')) {
                                    const parts = k.split('/');
                                    const fname = parts[parts.length - 1];
                                    const blob = new Blob([entries[k]]);
                                    const fileObj = new File([blob], fname, { type: 'application/octet-stream' });
                                    embeddedFilesMap[k] = fileObj;
                                }
                            });
                        }
                    }
                } catch (zipErr) {
                    // not a zip or unzip failed, fallback below
                }

                if (!projectData) {
                    // fallback: ä½œä¸ºçº¯ JSON æ–‡æœ¬è¯»å–
                    const text = (typeof e.target.result === 'string') ? e.target.result : new TextDecoder().decode(new Uint8Array(e.target.result));
                    projectData = JSON.parse(text);
                }

                // éªŒè¯æ–‡ä»¶æ ¼å¼
                if (!projectData.version || !projectData.scene) {
                    throw new Error('æ— æ•ˆçš„å·¥ç¨‹æ–‡ä»¶æ ¼å¼');
                }

                // æ¸…ç©ºå½“å‰åœºæ™¯
                this.clearScene();

                // æ¢å¤åœºæ™¯è®¾ç½®
                this.deserializeSettings(projectData.settings);

                // æ¢å¤ç›¸æœº
                this.deserializeCamera(projectData.camera);

                // æ¢å¤ç¯å…‰
                console.log('æ¢å¤ç¯å…‰æ•°æ®:', projectData.lights);
                this.deserializeLights(projectData.lights);

                // æ¢å¤æ¨¡å‹ï¼ˆå¦‚æœå·¥ç¨‹å†…åµŒäº†æ¨¡å‹æ–‡ä»¶åˆ™åŠ è½½è¿™äº›æ–‡ä»¶ï¼Œå¦åˆ™åˆ›å»ºå ä½ç¬¦ï¼‰
                console.log('æ¢å¤æ¨¡å‹æ•°æ®:', projectData.models);
                if (embeddedFilesMap) {
                    // éå† metadata ä¸­çš„æ¨¡å‹ä¿¡æ¯ï¼ŒæŒ‰åºåŠ è½½æˆ–åˆ›å»ºå ä½ç¬¦
                    const models = projectData.models || [];
                    let loadedModelsCount = 0;

                    models.forEach((modelData) => {
                        if (modelData.fileEntry && embeddedFilesMap[modelData.fileEntry]) {
                            const fileObj = embeddedFilesMap[modelData.fileEntry];
                            const ext = (fileObj.name.split('.').pop() || '').toLowerCase();

                            // å­˜å‚¨å˜æ¢ä¿¡æ¯ï¼Œç¨ååº”ç”¨
                            const transformData = {
                                position: modelData.position || [0,0,0],
                                rotation: modelData.rotation || [0,0,0],
                                scale: modelData.scale || [1,1,1],
                                visible: modelData.visible !== false,
                                userData: modelData.userData || {}
                            };

                            // ä¸´æ—¶ç¦ç”¨è‡ªåŠ¨ç¼©æ”¾å’Œå¯¹é½ï¼Œåœ¨åŠ è½½åæ‰‹åŠ¨åº”ç”¨å˜æ¢
                            const originalUniformAlign = this.uniformAlign;
                            const originalTargetSize = this.modelTargetSize;
                            this.uniformAlign = false; // ç¦ç”¨ç»Ÿä¸€å¯¹é½
                            this.modelTargetSize = 1.0; // ä½¿ç”¨åŸå§‹å¤§å°

                            // åŠ è½½æ¨¡å‹ï¼Œå¹¶åœ¨åŠ è½½å®Œæˆååº”ç”¨ä¿å­˜çš„å˜æ¢
                            this.loadModelWithTransform(fileObj, ext, transformData, () => {
                                loadedModelsCount++;
                                // æ¢å¤åŸå§‹è®¾ç½®
                                this.uniformAlign = originalUniformAlign;
                                this.modelTargetSize = originalTargetSize;

                                // æ‰€æœ‰æ¨¡å‹åŠ è½½å®Œæˆåæ›´æ–°æ–‡ä»¶åˆ—è¡¨
                                if (loadedModelsCount === models.length) {
                                    this.updateFileList();
                                }
                            });
                        } else {
                            // åˆ›å»ºå ä½ç¬¦ä»¥ä¿ç•™å˜æ¢ä¿¡æ¯
                            const placeholderGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                            const placeholderMaterial = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                transparent: true,
                                opacity: 0.5
                            });
                            const placeholder = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
                            placeholder.position.fromArray(modelData.position || [0,0,0]);
                            placeholder.rotation.fromArray(modelData.rotation || [0,0,0]);
                            placeholder.scale.fromArray(modelData.scale || [1,1,1]);
                            placeholder.visible = modelData.visible !== false;
                            placeholder.userData = modelData.userData || {};
                            this.scene.add(placeholder);
                            this.models.push({
                                id: modelData.id,
                                name: modelData.name,
                                fileName: modelData.fileName,
                                url: modelData.url,
                                object: placeholder,
                                isPlaceholder: true,
                                originalData: modelData
                            });
                        }
                    });

                    // å¦‚æœæ²¡æœ‰æ¨¡å‹éœ€è¦åŠ è½½ï¼Œç›´æ¥æ›´æ–°æ–‡ä»¶åˆ—è¡¨
                    if (models.length === 0 || models.every(m => !m.fileEntry || !embeddedFilesMap[m.fileEntry])) {
                        this.updateFileList();
                    }
                } else {
                    // æœªåµŒå…¥æ–‡ä»¶ï¼ŒæŒ‰è€é€»è¾‘åˆ›å»ºå ä½ç¬¦å¹¶æç¤ºç”¨æˆ·ä¸Šä¼ 
                    this.deserializeModels(projectData.models);
                }

                // è®¾ç½®å½“å‰å·¥ç¨‹æ–‡ä»¶å
                this.currentProjectFileName = file.name;
                this.hasUnsavedChanges = false;

                console.log('å·¥ç¨‹æ–‡ä»¶åŠ è½½æˆåŠŸ');
                alert('å·¥ç¨‹æ–‡ä»¶åŠ è½½æˆåŠŸï¼');

            } catch (error) {
                console.error('è§£æå·¥ç¨‹æ–‡ä»¶å¤±è´¥:', error);
                alert('åŠ è½½å·¥ç¨‹æ–‡ä»¶å¤±è´¥: ' + error.message);
            }
        };

        // ä»¥ ArrayBuffer è¯»å–ä»¥æ”¯æŒ ZIP å’Œæ™®é€š JSONï¼ˆåè€…ä¹Ÿèƒ½ä» buffer è½¬ä¸ºæ–‡æœ¬è§£æï¼‰
        reader.readAsArrayBuffer(file);

    } catch (error) {
        console.error('åŠ è½½å·¥ç¨‹æ–‡ä»¶å¤±è´¥:', error);
        alert('åŠ è½½å·¥ç¨‹æ–‡ä»¶å¤±è´¥: ' + error.message);
    }
};

// æ ‡è®°åœºæ™¯æœ‰æœªä¿å­˜çš„æ›´æ”¹
ModelViewer.prototype.markUnsavedChanges = function() {
    if (this.currentProjectFileName && !this.hasUnsavedChanges) {
        this.hasUnsavedChanges = true;
        console.log('åœºæ™¯æœ‰æœªä¿å­˜çš„æ›´æ”¹');
    }
};

// æ£€æŸ¥æ˜¯å¦æœ‰æœªä¿å­˜çš„æ›´æ”¹
ModelViewer.prototype.hasUnsavedChanges = function() {
    return this.hasUnsavedChanges;
};

// æ¸…ç©ºå½“å‰åœºæ™¯
ModelViewer.prototype.clearScene = function() {
    // ç§»é™¤æ‰€æœ‰æ¨¡å‹
    this.models.forEach(model => {
        if (model.object) {
            this.scene.remove(model.object);
        }
    });
    this.models = [];
    this.currentModel = null;

    // ç§»é™¤æ‰€æœ‰ç”¨æˆ·ç¯å…‰
    Object.keys(this.userLights).forEach(id => {
        this.removeLight(id);
    });
    this.userLights = {};
    this.lightIdCounter = 0;

    // é‡ç½®é€‰æ‹©æ¡†
    this.deselectModel();

    // æ›´æ–°UI
    this.updateFileList();
};

// åºåˆ—åŒ–åœºæ™¯
ModelViewer.prototype.serializeScene = function() {
    const sceneData = {
        background: null
    };

    if (this.scene.background) {
        if (this.scene.background.isColor) {
            sceneData.background = {
                type: 'color',
                value: '#' + this.scene.background.getHexString()
            };
        }
    }

    return sceneData;
};

// åºåˆ—åŒ–ç›¸æœº
ModelViewer.prototype.serializeCamera = function() {
    if (!this.camera) return null;

    return {
        position: this.camera.position.toArray(),
        target: this.controls ? this.controls.target.toArray() : [0, 0, 0],
        fov: this.camera.fov,
        near: this.camera.near,
        far: this.camera.far,
        zoom: this.camera.zoom
    };
};

// åºåˆ—åŒ–æ¨¡å‹
ModelViewer.prototype.serializeModels = function() {
    return this.models.map(model => ({
        id: model.id,
        name: model.name,
        fileName: model.fileName,
        url: model.url,
        position: model.object.position.toArray(),
        rotation: model.object.rotation.toArray(),
        scale: model.object.scale.toArray(),
        visible: model.object.visible,
        userData: model.object.userData || {}
    }));
};

// åºåˆ—åŒ–ç¯å…‰
ModelViewer.prototype.serializeLights = function() {
    const lightsData = {};

    // åºåˆ—åŒ–ç¯å¢ƒå…‰
    if (this.ambientLight) {
        lightsData.ambient = {
            intensity: this.ambientLight.intensity,
            color: '#' + this.ambientLight.color.getHexString()
        };
    }

    // åºåˆ—åŒ–é»˜è®¤æ–¹å‘å…‰
    if (this.directionalLight) {
        lightsData.directional = {
            intensity: this.directionalLight.intensity,
            color: '#' + this.directionalLight.color.getHexString(),
            position: this.directionalLight.position.toArray(),
            target: this.directionalLight.target.position.toArray()
        };
    }

    // åºåˆ—åŒ–ç”¨æˆ·åˆ›å»ºçš„ç¯å…‰
    lightsData.userLights = {};
    Object.entries(this.userLights).forEach(([id, lightEntry]) => {
        lightsData.userLights[id] = {
            type: lightEntry.type,
            intensity: lightEntry.light.intensity,
            color: '#' + lightEntry.light.color.getHexString(),
            position: lightEntry.light.position.toArray(),
            target: lightEntry.light.target ? lightEntry.light.target.position.toArray() : null
        };
    });

    return lightsData;
};

// åºåˆ—åŒ–è®¾ç½®
ModelViewer.prototype.serializeSettings = function() {
    return {
        modelTargetSize: this.modelTargetSize,
        uniformAlign: this.uniformAlign,
        gridVisible: this.gridHelper ? this.gridHelper.visible : false,
        axesVisible: this.axesHelper ? this.axesHelper.visible : false,
        helpersVisible: this.helpersVisible
    };
};

// ååºåˆ—åŒ–è®¾ç½®
ModelViewer.prototype.deserializeSettings = function(settings) {
    if (!settings) return;

    if (settings.modelTargetSize !== undefined) {
        this.modelTargetSize = settings.modelTargetSize;
        updateModelTargetSize(this.modelTargetSize);
    }

    if (settings.uniformAlign !== undefined) {
        this.uniformAlign = settings.uniformAlign;
        const checkbox = document.getElementById('uniformAlign');
        if (checkbox) checkbox.checked = this.uniformAlign;
    }

    if (settings.gridVisible !== undefined) {
        const checkbox = document.getElementById('toggleGrid');
        if (checkbox) {
            checkbox.checked = settings.gridVisible;
            toggleGrid(settings.gridVisible);
        }
    }

    if (settings.helpersVisible !== undefined) {
        this.helpersVisible = settings.helpersVisible;
        const checkbox = document.getElementById('toggleHelpers');
        if (checkbox) {
            checkbox.checked = this.helpersVisible;
            toggleLightHelpers(this.helpersVisible);
        }
    }
};

// ååºåˆ—åŒ–ç›¸æœº
ModelViewer.prototype.deserializeCamera = function(cameraData) {
    if (!cameraData || !this.camera || !this.controls) return;

    if (cameraData.position) {
        this.camera.position.fromArray(cameraData.position);
    }

    if (cameraData.target) {
        this.controls.target.fromArray(cameraData.target);
    }

    if (cameraData.fov !== undefined) {
        this.camera.fov = cameraData.fov;
        this.camera.updateProjectionMatrix();
        setCameraFovFromUI(cameraData.fov);
    }

    if (cameraData.zoom !== undefined) {
        this.camera.zoom = cameraData.zoom;
        this.camera.updateProjectionMatrix();
    }

    this.controls.update();
};

// ååºåˆ—åŒ–ç¯å…‰
ModelViewer.prototype.deserializeLights = function(lightsData) {
    if (!lightsData) return;

    console.log('æ­£åœ¨æ¢å¤ç¯å…‰:', lightsData);

    // æ¢å¤ç¯å¢ƒå…‰
    if (lightsData.ambient) {
        if (this.ambientLight) {
            this.ambientLight.intensity = lightsData.ambient.intensity;
            this.ambientLight.color.setStyle(lightsData.ambient.color);
        }
        updateAmbientIntensity(lightsData.ambient.intensity);
    }

    // æ¢å¤é»˜è®¤æ–¹å‘å…‰
    if (lightsData.directional) {
        if (this.directionalLight) {
            this.directionalLight.intensity = lightsData.directional.intensity;
            this.directionalLight.color.setStyle(lightsData.directional.color);
            this.directionalLight.position.fromArray(lightsData.directional.position);
            if (lightsData.directional.target) {
                this.directionalLight.target.position.fromArray(lightsData.directional.target);
            }
        }
        updateDirectionalIntensity(lightsData.directional.intensity);
        updateDirectionalPos(
            lightsData.directional.position[0],
            lightsData.directional.position[1],
            lightsData.directional.position[2]
        );
    }

    // æ¢å¤ç”¨æˆ·ç¯å…‰
    if (lightsData.userLights) {
        Object.entries(lightsData.userLights).forEach(([id, lightData]) => {
            this.addLight('directional');
            // è·å–åˆšæ·»åŠ çš„ç¯å…‰
            const newLightId = this.lightIdCounter - 1;
            const lightEntry = this.userLights[newLightId];

            if (lightEntry) {
                lightEntry.light.intensity = lightData.intensity;
                lightEntry.light.color.setStyle(lightData.color);
                lightEntry.light.position.fromArray(lightData.position);
                if (lightData.target && lightEntry.light.target) {
                    lightEntry.light.target.position.fromArray(lightData.target);
                }
            }
        });
    }
};

// ååºåˆ—åŒ–æ¨¡å‹ï¼ˆå¼‚æ­¥åŠ è½½ï¼‰
ModelViewer.prototype.deserializeModels = function(modelsData) {
    if (!modelsData || !Array.isArray(modelsData)) return;

    let loadedCount = 0;
    const totalCount = modelsData.length;

    modelsData.forEach(modelData => {
        // è¿™é‡Œéœ€è¦æ ¹æ®æ–‡ä»¶URLé‡æ–°åŠ è½½æ¨¡å‹æˆ–åˆ›å»ºå ä½ç¬¦
        // å¦‚æœè°ƒç”¨æ–¹ä¼ å…¥äº†åµŒå…¥æ–‡ä»¶ï¼Œåˆ™ loadProject ä¼šç›´æ¥åŠ è½½ï¼Œä¸ç»è¿‡æœ¬å‡½æ•°
        console.log(`æ¨¡å‹ ${modelData.name} çš„ä½ç½®ä¿¡æ¯å·²ä¿å­˜ï¼Œä½†éœ€è¦é‡æ–°ä¸Šä¼ æ–‡ä»¶: ${modelData.fileName}`);

        // åˆ›å»ºä¸€ä¸ªå ä½ç¬¦æ¨¡å‹æ¥ä¿å­˜å˜æ¢ä¿¡æ¯
        const placeholderGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const placeholderMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.5
        });
        const placeholder = new THREE.Mesh(placeholderGeometry, placeholderMaterial);

        placeholder.position.fromArray(modelData.position || [0,0,0]);
        placeholder.rotation.fromArray(modelData.rotation || [0,0,0]);
        placeholder.scale.fromArray(modelData.scale || [1,1,1]);
        placeholder.visible = modelData.visible !== false;
        placeholder.userData = modelData.userData || {};

        // æ·»åŠ åˆ°åœºæ™¯ä½†æ ‡è®°ä¸ºå ä½ç¬¦
        this.scene.add(placeholder);

        const modelEntry = {
            id: modelData.id,
            name: modelData.name,
            fileName: modelData.fileName,
            url: modelData.url,
            object: placeholder,
            isPlaceholder: true,
            originalData: modelData
        };

        this.models.push(modelEntry);
        this.updateFileList();
    });

    if (totalCount > 0) {
        alert(`å·¥ç¨‹æ–‡ä»¶åŒ…å« ${totalCount} ä¸ªæ¨¡å‹ã€‚ç”±äºæµè§ˆå™¨å®‰å…¨é™åˆ¶ï¼Œè¯·é‡æ–°ä¸Šä¼ è¿™äº›æ¨¡å‹æ–‡ä»¶ä»¥æ¢å¤å®Œæ•´åœºæ™¯ã€‚`);
    }
};

// åˆå§‹åŒ–æŸ¥çœ‹å™¨
document.addEventListener('DOMContentLoaded', () => {
    try {
        console.log('å¼€å§‹åˆå§‹åŒ–ğŸ”µBB 3DæŸ¥çœ‹å™¨...');
        viewer = new ModelViewer();
        console.log('ğŸ”µBB 3DæŸ¥çœ‹å™¨åˆå§‹åŒ–æˆåŠŸ');
        // å·¦ä¾§èµ„æºé¢æ¿å°†é€šè¿‡ updateFileList ç›´æ¥å†™å…¥ï¼Œæ— éœ€é•œåƒ
        // åŒæ­¥åˆå§‹ç¯å…‰UIï¼ˆç¡®ä¿æ»‘å—å€¼ä¸å½“å‰ç¯å¢ƒå…‰ä¸€è‡´ï¼‰
        try {
            viewer.resetLighting();
        } catch (e) {
            console.warn('åˆå§‹åŒ–ç¯å…‰UIå¤±è´¥', e);
        }

        // åŒæ­¥åˆå§‹æ¨¡å‹å°ºå¯¸UI
        try {
            const modelSizeEl = document.getElementById('modelSizeVal');
            if (modelSizeEl) {
                modelSizeEl.textContent = viewer.modelTargetSize.toFixed(1);
            }
            const modelSizeSlider = document.querySelector('input[oninput*="updateModelTargetSize"]');
            if (modelSizeSlider) {
                modelSizeSlider.value = viewer.modelTargetSize;
            }
        } catch (e) {
            console.warn('åˆå§‹åŒ–æ¨¡å‹å°ºå¯¸UIå¤±è´¥', e);
        }

        // åˆå§‹åŒ–å·¥ç¨‹çŠ¶æ€æ˜¾ç¤º
        try {
            updateProjectStatus();
        } catch (e) {
            console.warn('åˆå§‹åŒ–å·¥ç¨‹çŠ¶æ€æ˜¾ç¤ºå¤±è´¥', e);
        }
        // å°è¯•æ¢å¤ä¹‹å‰ä¿å­˜çš„æ–‡ä»¶å¥æŸ„ï¼ˆå¦‚æœæµè§ˆå™¨æ”¯æŒï¼‰
        try {
            if (viewer && typeof viewer.restoreSavedProjectHandle === 'function') {
                viewer.restoreSavedProjectHandle().then(() => {
                    try { updateProjectStatus(); } catch (e) {}
                }).catch((err) => {
                    console.warn('æ¢å¤ä¿å­˜çš„é¡¹ç›®å¥æŸ„å¤±è´¥:', err);
                });
            }
        } catch (e) {
            console.warn('å°è¯•æ¢å¤é¡¹ç›®å¥æŸ„æ—¶å‡ºé”™', e);
        }
    } catch (error) {
        console.error('ğŸ”µBB 3DæŸ¥çœ‹å™¨åˆå§‹åŒ–å¤±è´¥:', error);
        document.getElementById('viewer').innerHTML = '<div style="color: red; padding: 20px;">åˆå§‹åŒ–å¤±è´¥: ' + error.message + '</div>';
    }
});

// å°†æ§åˆ¶åŒºå—è½¬æ¢ä¸ºå¯æŠ˜å é¢æ¿
function makeControlGroupsCollapsible() {
    const selector = '.sidebar .control-group';
    const groups = document.querySelectorAll(selector);
    groups.forEach((g) => {
        if (!g || g.dataset.collapsible === '1') return;
        // å°è¯•æå–ç¬¬ä¸€ä¸ªå­å…ƒç´ ä½œä¸ºæ ‡é¢˜ï¼ˆé€šå¸¸æ˜¯ <div style="font-weight:bold">ï¼‰
        let first = g.firstElementChild;
        let titleText = '';
        if (first && first.tagName.toLowerCase() === 'div' && first.childElementCount === 0 && first.innerText && first.innerText.trim().length > 0) {
            titleText = first.innerText.trim();
            first.remove();
        } else {
            // fallbackï¼šä½¿ç”¨ data-title æˆ–é»˜è®¤æ–‡æœ¬
            titleText = g.getAttribute('data-title') || '';
        }
        // æ£€æŸ¥çˆ¶å®¹å™¨ï¼ˆä¾§è¾¹æ ï¼‰
        const container = g.closest('.sidebar');
        const isFirstInRightPanel = false;

        // å°†å‰©ä½™å†…å®¹åŒ…è£¹åˆ° content å®¹å™¨ä¸­
        const content = document.createElement('div');
        content.className = 'content';
        while (g.firstChild) {
            content.appendChild(g.firstChild);
        }

        if (isFirstInRightPanel || !titleText) {
            // ä¸åˆ›å»ºå¯æŠ˜å å¤´éƒ¨ï¼Œç›´æ¥æ’å…¥ contentï¼ˆä¿æŒå§‹ç»ˆå±•å¼€ï¼‰
            g.appendChild(content);
            g.dataset.collapsible = '1';
        } else {
            const header = document.createElement('div');
            header.className = 'collapsible-header';
            header.innerHTML = `<span class="chevron">â–¾</span><span class="hdr-text">${titleText}</span>`;
            g.appendChild(header);
            g.appendChild(content);
            g.dataset.collapsible = '1';

            // äº¤äº’ï¼šç‚¹å‡»æˆ–é”®ç›˜è§¦å‘æŠ˜å 
            header.setAttribute('role', 'button');
            header.setAttribute('tabindex', '0');
            header.setAttribute('aria-expanded', 'true');
            header.addEventListener('click', () => {
                const collapsed = g.classList.toggle('collapsed');
                header.setAttribute('aria-expanded', (!collapsed).toString());
            });
            header.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    header.click();
                }
            });
        }
    });
}

// åœ¨é¡µé¢åŠ è½½åç«‹å³å¯ç”¨æŠ˜å é¢æ¿
document.addEventListener('DOMContentLoaded', () => {
    try { makeControlGroupsCollapsible(); } catch (e) { /* ignore */ }
});

// ========================================
// å·¥ç¨‹æ–‡ä»¶åŠŸèƒ½
// ========================================

// ä¿å­˜å·¥ç¨‹æ–‡ä»¶
function saveProject() {
    if (!viewer) {
        alert('æŸ¥çœ‹å™¨æœªåˆå§‹åŒ–');
        return;
    }
    viewer.saveProject();
    updateProjectStatus();
}

// å¦å­˜ä¸ºå·¥ç¨‹æ–‡ä»¶
function saveProjectAs() {
    if (!viewer) {
        alert('æŸ¥çœ‹å™¨æœªåˆå§‹åŒ–');
        return;
    }
    viewer.saveProjectAs();
    updateProjectStatus();
}

// åŠ è½½å·¥ç¨‹æ–‡ä»¶
function loadProjectFromFile(file) {
    if (!viewer) {
        alert('æŸ¥çœ‹å™¨æœªåˆå§‹åŒ–');
        return;
    }
    if (!file) return;

    // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
    if (!file.name.toLowerCase().endsWith('.bbproject')) {
        alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„å·¥ç¨‹æ–‡ä»¶ (.bbproject)');
        return;
    }

    // ä¿å­˜å½“å‰æ‰“å¼€çš„æ–‡ä»¶ä¿¡æ¯ï¼Œç”¨äºåç»­è¦†ç›–ä¿å­˜
    viewer.currentProjectFileName = file.name;
    viewer.currentProjectFileHandle = null; // File Input API æ— æ³•è·å–å¥æŸ„

    // æ£€æŸ¥æ˜¯å¦æœ‰æœªä¿å­˜çš„æ›´æ”¹
    if (viewer.hasUnsavedChanges && confirm('å½“å‰å·¥ç¨‹æœ‰æœªä¿å­˜çš„æ›´æ”¹ï¼Œç¡®å®šè¦æ‰“å¼€æ–°å·¥ç¨‹å—ï¼Ÿ')) {
        viewer.loadProject(file);
        updateProjectStatus();
    } else if (!viewer.hasUnsavedChanges) {
        viewer.loadProject(file);
        updateProjectStatus();
    }
}

// æ›´æ–°å·¥ç¨‹çŠ¶æ€æ˜¾ç¤º
function updateProjectStatus() {
    if (!viewer) return;

    const statusEl = document.getElementById('projectStatus');
    const saveBtn = document.getElementById('saveBtn');

    if (statusEl) {
        if (viewer.currentProjectFileName) {
            const status = viewer.hasUnsavedChanges ? ' (æœ‰æ›´æ”¹)' : ' (å·²ä¿å­˜)';
            statusEl.textContent = viewer.currentProjectFileName + status;
            statusEl.style.color = viewer.hasUnsavedChanges ? '#ff6b35' : '#28a745';
        } else {
            statusEl.textContent = 'æœªä¿å­˜';
            statusEl.style.color = 'var(--muted)';
        }
    }

    // æ›´æ–°ä¿å­˜æŒ‰é’®æ–‡æœ¬
    if (saveBtn) {
        if (viewer.currentProjectFileName) {
            saveBtn.textContent = 'ğŸ’¾ è¦†ç›–ä¿å­˜';
            saveBtn.title = `ä¿å­˜åˆ° ${viewer.currentProjectFileName}`;
        } else {
            saveBtn.textContent = 'ğŸ’¾ ä¿å­˜å·¥ç¨‹';
            saveBtn.title = 'é¦–æ¬¡ä¿å­˜éœ€è¦é€‰æ‹©æ–‡ä»¶ä½ç½®';
        }
    }
}

// åœ¨ä¸æ”¯æŒ File System Access API çš„æµè§ˆå™¨ä¸­æ˜¾ç¤ºè¯´æ˜
function showFsApiInfo() {
    const msg = 'å½“å‰æµè§ˆå™¨ä¸æ”¯æŒè¦†ç›–ä¿å­˜ï¼ˆFile System Access APIï¼‰ã€‚\\n\\n' +
        'å»ºè®®ï¼š\\n' +
        '- åœ¨æ”¯æŒçš„ Chromium æµè§ˆå™¨ï¼ˆChrome/Edge 86+ï¼‰ä¸­ä½¿ç”¨â€œå¦å­˜ä¸ºâ€ä»¥å¯ç”¨è¦†ç›–ä¿å­˜å¹¶å…è®¸æ— æç¤ºè¦†ç›–ã€‚\\n' +
        '- åœ¨å½“å‰æµè§ˆå™¨ä½¿ç”¨â€œå¦å­˜ä¸ºâ€ä¿å­˜å·¥ç¨‹æ–‡ä»¶ï¼ˆä¼šä¸‹è½½ï¼‰ï¼Œåç»­å¯ä½¿ç”¨â€œæ‰“å¼€å·¥ç¨‹â€åŠ è½½ã€‚\\n' +
        '- å¦‚æœæ‚¨æƒ³è¦å•æ–‡ä»¶ä¿å­˜ï¼ˆåŒ…å«æ¨¡å‹ï¼‰ï¼Œæˆ‘å¯ä»¥å®ç°å°†æ¨¡å‹åµŒå…¥ .bbprojectï¼ˆä½†æ–‡ä»¶ä¼šå˜å¤§ï¼‰ã€‚';
    alert(msg);
}

function checkFsApiSupportAndRender() {
    const statusEl = document.getElementById('projectStatus');
    if (!statusEl) return;
    const noticeId = 'fsApiNotice';
    let noticeEl = document.getElementById(noticeId);
    if (!window.showSaveFilePicker) {
        if (!noticeEl) {
            noticeEl = document.createElement('div');
            noticeEl.id = noticeId;
            noticeEl.style.fontSize = '12px';
            noticeEl.style.marginTop = '6px';
            noticeEl.style.color = 'var(--muted)';
            noticeEl.innerHTML = 'æç¤ºï¼šå½“å‰æµè§ˆå™¨ä¸æ”¯æŒè¦†ç›–ä¿å­˜ã€‚' +
                ' ä½¿ç”¨â€œå¦å­˜ä¸ºâ€å¯ä¿å­˜æ–‡ä»¶ï¼›åœ¨æ”¯æŒçš„ Chromium æµè§ˆå™¨ä¸­å¯è·å¾—è¦†ç›–ä¿å­˜ä½“éªŒã€‚ ' +
                '<button class="control-btn" style="display:inline-block; padding:4px 8px; margin-left:8px; font-size:12px;" onclick="showFsApiInfo()">äº†è§£æ›´å¤š</button>';
            statusEl.parentNode.insertBefore(noticeEl, statusEl.nextSibling);
        }
    } else {
        if (noticeEl) noticeEl.remove();
    }
}

// ä¾§æ æ‹‰ä¼¸å™¨é€»è¾‘
// sidebar resizer removed - fixed sidebar width
</script>
</body>
</html>
